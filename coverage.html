
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>receiver: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/npcomplete777/snowflakereceiver/receiver/client.go (76.6%)</option>
				
				<option value="file1">github.com/npcomplete777/snowflakereceiver/receiver/config.go (74.8%)</option>
				
				<option value="file2">github.com/npcomplete777/snowflakereceiver/receiver/factory.go (81.8%)</option>
				
				<option value="file3">github.com/npcomplete777/snowflakereceiver/receiver/scraper.go (85.8%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package snowflakereceiver

import (
    "context"
    "database/sql"
    "fmt"
    
    _ "github.com/snowflakedb/gosnowflake"
    "go.uber.org/zap"
)

type snowflakeClient struct {
    logger *zap.Logger
    config *Config
    db     *sql.DB
}

type snowflakeMetrics struct {
    currentQueries        []currentQueryRow
    warehouseLoad         []warehouseLoadRow
    queryStats            []queryStatRow
    creditUsage           []creditUsageRow
    storageUsage          []storageUsageRow
    loginHistory          []loginHistoryRow
    pipeUsage             []pipeUsageRow
    databaseStorage       []databaseStorageRow
    taskHistory           []taskHistoryRow
    replicationUsage      []replicationUsageRow
    autoClusteringHistory []autoClusteringRow
    eventQueryLogs        []eventTableRow
    eventTaskLogs         []eventTableRow
    eventFunctionLogs     []eventTableRow
    eventProcedureLogs    []eventTableRow
    orgCreditUsage        []orgCreditUsageRow
    orgStorageUsage       []orgStorageUsageRow
    orgDataTransfer       []orgDataTransferRow
    orgContractUsage      []orgContractUsageRow
    customQueryResults    []customQueryResult
}

type currentQueryRow struct {
    warehouseName    sql.NullString
    queryType        sql.NullString
    executionStatus  sql.NullString
    queryCount       int64
    avgExecutionTime sql.NullFloat64
    avgBytesScanned  sql.NullFloat64
}

type warehouseLoadRow struct {
    warehouseName          sql.NullString
    avgRunning             sql.NullFloat64
    avgQueuedLoad          sql.NullFloat64
    avgQueuedProvisioning  sql.NullFloat64
    avgBlocked             sql.NullFloat64
}

type queryStatRow struct {
    warehouseName      sql.NullString
    queryType          sql.NullString
    executionStatus    sql.NullString
    queryCount         int64
    avgExecutionTime   sql.NullFloat64
    avgBytesScanned    sql.NullFloat64
    avgBytesWritten    sql.NullFloat64
    avgRowsProduced    sql.NullFloat64
    avgCompilationTime sql.NullFloat64
}

type creditUsageRow struct {
    warehouseName       sql.NullString
    totalCredits        float64
    computeCredits      sql.NullFloat64
    cloudServiceCredits sql.NullFloat64
}

type storageUsageRow struct {
    totalStorageBytes sql.NullFloat64
    stageBytes        sql.NullFloat64
    failsafeBytes     sql.NullFloat64
}

type loginHistoryRow struct {
    isSuccess  string
    errorCode  sql.NullString
    loginCount int64
}

type pipeUsageRow struct {
    pipeName      sql.NullString
    totalCredits  float64
    bytesInserted sql.NullFloat64
    filesInserted sql.NullInt64
}

type databaseStorageRow struct {
    databaseName      sql.NullString
    avgDatabaseBytes  sql.NullFloat64
    avgFailsafeBytes  sql.NullFloat64
}

type taskHistoryRow struct {
    databaseName      sql.NullString
    schemaName        sql.NullString
    taskName          sql.NullString
    state             sql.NullString
    executionCount    int64
    avgExecutionTime  sql.NullFloat64
}

type replicationUsageRow struct {
    databaseName     sql.NullString
    totalCredits     float64
    bytesTransferred sql.NullFloat64
}

type autoClusteringRow struct {
    databaseName      sql.NullString
    schemaName        sql.NullString
    tableName         sql.NullString
    totalCredits      float64
    bytesReclustered  sql.NullFloat64
    rowsReclustered   sql.NullFloat64
}

type eventTableRow struct {
    eventType    string
    severity     sql.NullString
    errorMessage sql.NullString
}

type orgCreditUsageRow struct {
    organizationName sql.NullString
    accountName      sql.NullString
    serviceType      sql.NullString
    totalCredits     float64
}

type orgStorageUsageRow struct {
    organizationName sql.NullString
    accountName      sql.NullString
    avgStorageBytes  sql.NullFloat64
    avgStageBytes    sql.NullFloat64
    avgFailsafeBytes sql.NullFloat64
}

type orgDataTransferRow struct {
    organizationName      sql.NullString
    sourceAccountName     sql.NullString
    targetAccountName     sql.NullString
    sourceRegion          sql.NullString
    targetRegion          sql.NullString
    totalBytesTransferred sql.NullFloat64
}

type orgContractUsageRow struct {
    organizationName  sql.NullString
    contractNumber    sql.NullInt64
    totalCreditsUsed  float64
    totalCreditsBilled sql.NullFloat64
}

type customQueryResult struct {
    name       string
    metricType string
    rows       []map[string]interface{}
}

func newSnowflakeClient(logger *zap.Logger, config *Config) (*snowflakeClient, error) <span class="cov8" title="1">{
    return &amp;snowflakeClient{
        logger: logger,
        config: config,
    }, nil
}</span>

func (c *snowflakeClient) connect(ctx context.Context) error <span class="cov0" title="0">{
    if c.db != nil </span><span class="cov0" title="0">{
        return nil
    }</span>
    
    <span class="cov0" title="0">dsn := fmt.Sprintf("%s:%s@%s/%s/%s?warehouse=%s",
        c.config.User,
        c.config.Password,
        c.config.Account,
        c.config.Database,
        c.config.Schema,
        c.config.Warehouse,
    )
    
    db, err := sql.Open("snowflake", dsn)
    if err != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("failed to open Snowflake connection: %w", err)
    }</span>
    
    <span class="cov0" title="0">if err := db.PingContext(ctx); err != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("failed to ping Snowflake: %w", err)
    }</span>
    
    <span class="cov0" title="0">c.db = db
    c.logger.Info("Successfully connected to Snowflake")
    return nil</span>
}

func (c *snowflakeClient) queryMetrics(ctx context.Context) (*snowflakeMetrics, error) <span class="cov8" title="1">{
    metrics := &amp;snowflakeMetrics{}
    
    if c.config.Metrics.CurrentQueries.Enabled </span><span class="cov8" title="1">{
        if err := c.queryCurrentQueries(ctx, metrics); err != nil </span><span class="cov8" title="1">{
            c.logger.Warn("Failed to query current queries", zap.Error(err))
        }</span>
    }
    
    <span class="cov8" title="1">if c.config.Metrics.WarehouseLoad.Enabled </span><span class="cov8" title="1">{
        if err := c.queryWarehouseLoad(ctx, metrics); err != nil </span><span class="cov0" title="0">{
            c.logger.Warn("Failed to query warehouse load", zap.Error(err))
        }</span>
    }
    
    <span class="cov8" title="1">if c.config.Metrics.QueryHistory.Enabled </span><span class="cov8" title="1">{
        if err := c.queryQueryHistory(ctx, metrics); err != nil </span><span class="cov8" title="1">{
            c.logger.Warn("Failed to query query history", zap.Error(err))
        }</span>
    }
    
    <span class="cov8" title="1">if c.config.Metrics.CreditUsage.Enabled </span><span class="cov8" title="1">{
        if err := c.queryCreditUsage(ctx, metrics); err != nil </span><span class="cov8" title="1">{
            c.logger.Warn("Failed to query credit usage", zap.Error(err))
        }</span>
    }
    
    <span class="cov8" title="1">if c.config.Metrics.StorageMetrics.Enabled </span><span class="cov8" title="1">{
        if err := c.queryStorageUsage(ctx, metrics); err != nil </span><span class="cov8" title="1">{
            c.logger.Warn("Failed to query storage usage", zap.Error(err))
        }</span>
    }
    
    <span class="cov8" title="1">if c.config.Metrics.LoginHistory.Enabled </span><span class="cov8" title="1">{
        if err := c.queryLoginHistory(ctx, metrics); err != nil </span><span class="cov8" title="1">{
            c.logger.Warn("Failed to query login history", zap.Error(err))
        }</span>
    }
    
    <span class="cov8" title="1">if c.config.Metrics.DataPipeline.Enabled </span><span class="cov8" title="1">{
        if err := c.queryPipeUsage(ctx, metrics); err != nil </span><span class="cov8" title="1">{
            c.logger.Warn("Failed to query pipe usage", zap.Error(err))
        }</span>
    }
    
    <span class="cov8" title="1">if c.config.Metrics.DatabaseStorage.Enabled </span><span class="cov8" title="1">{
        if err := c.queryDatabaseStorage(ctx, metrics); err != nil </span><span class="cov8" title="1">{
            c.logger.Warn("Failed to query database storage", zap.Error(err))
        }</span>
    }
    
    <span class="cov8" title="1">if c.config.Metrics.TaskHistory.Enabled </span><span class="cov8" title="1">{
        if err := c.queryTaskHistory(ctx, metrics); err != nil </span><span class="cov8" title="1">{
            c.logger.Warn("Failed to query task history", zap.Error(err))
        }</span>
    }
    
    <span class="cov8" title="1">if c.config.Metrics.ReplicationUsage.Enabled </span><span class="cov8" title="1">{
        if err := c.queryReplicationUsage(ctx, metrics); err != nil </span><span class="cov8" title="1">{
            c.logger.Warn("Failed to query replication usage", zap.Error(err))
        }</span>
    }
    
    <span class="cov8" title="1">if c.config.Metrics.AutoClusteringHistory.Enabled </span><span class="cov8" title="1">{
        if err := c.queryAutoClusteringHistory(ctx, metrics); err != nil </span><span class="cov8" title="1">{
            c.logger.Warn("Failed to query auto-clustering history", zap.Error(err))
        }</span>
    }
    
    <span class="cov8" title="1">if c.config.EventTables.Enabled </span><span class="cov0" title="0">{
        if c.config.EventTables.QueryLogs.Enabled </span><span class="cov0" title="0">{
            if err := c.queryEventTableLogs(ctx, metrics, "QUERY"); err != nil </span><span class="cov0" title="0">{
                c.logger.Warn("Failed to query event table query logs", zap.Error(err))
            }</span>
        }
        <span class="cov0" title="0">if c.config.EventTables.TaskLogs.Enabled </span><span class="cov0" title="0">{
            if err := c.queryEventTableLogs(ctx, metrics, "TASK"); err != nil </span><span class="cov0" title="0">{
                c.logger.Warn("Failed to query event table task logs", zap.Error(err))
            }</span>
        }
        <span class="cov0" title="0">if c.config.EventTables.FunctionLogs.Enabled </span><span class="cov0" title="0">{
            if err := c.queryEventTableLogs(ctx, metrics, "FUNCTION"); err != nil </span><span class="cov0" title="0">{
                c.logger.Warn("Failed to query event table function logs", zap.Error(err))
            }</span>
        }
        <span class="cov0" title="0">if c.config.EventTables.ProcedureLogs.Enabled </span><span class="cov0" title="0">{
            if err := c.queryEventTableLogs(ctx, metrics, "PROCEDURE"); err != nil </span><span class="cov0" title="0">{
                c.logger.Warn("Failed to query event table procedure logs", zap.Error(err))
            }</span>
        }
    }
    
    <span class="cov8" title="1">if c.config.Organization.Enabled </span><span class="cov0" title="0">{
        if c.config.Organization.OrgCreditUsage.Enabled </span><span class="cov0" title="0">{
            if err := c.queryOrgCreditUsage(ctx, metrics); err != nil </span><span class="cov0" title="0">{
                c.logger.Warn("Failed to query org credit usage", zap.Error(err))
            }</span>
        }
        <span class="cov0" title="0">if c.config.Organization.OrgStorageUsage.Enabled </span><span class="cov0" title="0">{
            if err := c.queryOrgStorageUsage(ctx, metrics); err != nil </span><span class="cov0" title="0">{
                c.logger.Warn("Failed to query org storage usage", zap.Error(err))
            }</span>
        }
        <span class="cov0" title="0">if c.config.Organization.OrgDataTransfer.Enabled </span><span class="cov0" title="0">{
            if err := c.queryOrgDataTransfer(ctx, metrics); err != nil </span><span class="cov0" title="0">{
                c.logger.Warn("Failed to query org data transfer", zap.Error(err))
            }</span>
        }
        <span class="cov0" title="0">if c.config.Organization.OrgContractUsage.Enabled </span><span class="cov0" title="0">{
            if err := c.queryOrgContractUsage(ctx, metrics); err != nil </span><span class="cov0" title="0">{
                c.logger.Warn("Failed to query org contract usage", zap.Error(err))
            }</span>
        }
    }
    
    <span class="cov8" title="1">if c.config.CustomQueries.Enabled </span><span class="cov0" title="0">{
        for _, query := range c.config.CustomQueries.Queries </span><span class="cov0" title="0">{
            if err := c.executeCustomQuery(ctx, metrics, &amp;query); err != nil </span><span class="cov0" title="0">{
                c.logger.Warn("Failed to execute custom query",
                    zap.String("query_name", query.Name),
                    zap.Error(err))
            }</span>
        }
    }
    
    <span class="cov8" title="1">return metrics, nil</span>
}

func (c *snowflakeClient) queryCurrentQueries(ctx context.Context, metrics *snowflakeMetrics) error <span class="cov8" title="1">{
    query := `
        SELECT 
            WAREHOUSE_NAME,
            QUERY_TYPE,
            EXECUTION_STATUS,
            COUNT(*) as QUERY_COUNT,
            AVG(TOTAL_ELAPSED_TIME) as AVG_EXECUTION_TIME,
            AVG(BYTES_SCANNED) as AVG_BYTES_SCANNED
        FROM TABLE(SNOWFLAKE.INFORMATION_SCHEMA.QUERY_HISTORY())
        WHERE START_TIME &gt;= DATEADD(minute, -5, CURRENT_TIMESTAMP())
        GROUP BY WAREHOUSE_NAME, QUERY_TYPE, EXECUTION_STATUS
    `
    
    rows, err := c.db.QueryContext(ctx, query)
    if err != nil </span><span class="cov8" title="1">{
        return fmt.Errorf("failed to query current queries: %w", err)
    }</span>
    <span class="cov8" title="1">defer rows.Close()
    
    for rows.Next() </span><span class="cov8" title="1">{
        var row currentQueryRow
        if err := rows.Scan(
            &amp;row.warehouseName,
            &amp;row.queryType,
            &amp;row.executionStatus,
            &amp;row.queryCount,
            &amp;row.avgExecutionTime,
            &amp;row.avgBytesScanned,
        ); err != nil </span><span class="cov0" title="0">{
            return fmt.Errorf("failed to scan current query row: %w", err)
        }</span>
        <span class="cov8" title="1">metrics.currentQueries = append(metrics.currentQueries, row)</span>
    }
    
    <span class="cov8" title="1">return rows.Err()</span>
}

func (c *snowflakeClient) queryWarehouseLoad(ctx context.Context, metrics *snowflakeMetrics) error <span class="cov8" title="1">{
    query := `
        SELECT 
            WAREHOUSE_NAME,
            AVG(AVG_RUNNING) as AVG_RUNNING,
            AVG(AVG_QUEUED_LOAD) as AVG_QUEUED_LOAD,
            AVG(AVG_QUEUED_PROVISIONING) as AVG_QUEUED_PROVISIONING,
            AVG(AVG_BLOCKED) as AVG_BLOCKED
        FROM TABLE(SNOWFLAKE.INFORMATION_SCHEMA.WAREHOUSE_LOAD_HISTORY())
        WHERE START_TIME &gt;= DATEADD(minute, -5, CURRENT_TIMESTAMP())
        GROUP BY WAREHOUSE_NAME
    `
    
    rows, err := c.db.QueryContext(ctx, query)
    if err != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("failed to query warehouse load: %w", err)
    }</span>
    <span class="cov8" title="1">defer rows.Close()
    
    for rows.Next() </span><span class="cov8" title="1">{
        var row warehouseLoadRow
        if err := rows.Scan(
            &amp;row.warehouseName,
            &amp;row.avgRunning,
            &amp;row.avgQueuedLoad,
            &amp;row.avgQueuedProvisioning,
            &amp;row.avgBlocked,
        ); err != nil </span><span class="cov0" title="0">{
            return fmt.Errorf("failed to scan warehouse load row: %w", err)
        }</span>
        <span class="cov8" title="1">metrics.warehouseLoad = append(metrics.warehouseLoad, row)</span>
    }
    
    <span class="cov8" title="1">return rows.Err()</span>
}

func (c *snowflakeClient) queryQueryHistory(ctx context.Context, metrics *snowflakeMetrics) error <span class="cov8" title="1">{
    query := `
        SELECT 
            WAREHOUSE_NAME,
            QUERY_TYPE,
            EXECUTION_STATUS,
            COUNT(*) as QUERY_COUNT,
            AVG(TOTAL_ELAPSED_TIME) as AVG_EXECUTION_TIME,
            AVG(BYTES_SCANNED) as AVG_BYTES_SCANNED,
            AVG(BYTES_WRITTEN) as AVG_BYTES_WRITTEN,
            AVG(ROWS_PRODUCED) as AVG_ROWS_PRODUCED,
            AVG(COMPILATION_TIME) as AVG_COMPILATION_TIME
        FROM SNOWFLAKE.ACCOUNT_USAGE.QUERY_HISTORY
        WHERE START_TIME &gt;= DATEADD(hour, -1, CURRENT_TIMESTAMP())
        GROUP BY WAREHOUSE_NAME, QUERY_TYPE, EXECUTION_STATUS
    `
    
    rows, err := c.db.QueryContext(ctx, query)
    if err != nil </span><span class="cov8" title="1">{
        return fmt.Errorf("failed to query query history: %w", err)
    }</span>
    <span class="cov8" title="1">defer rows.Close()
    
    for rows.Next() </span><span class="cov8" title="1">{
        var row queryStatRow
        if err := rows.Scan(
            &amp;row.warehouseName,
            &amp;row.queryType,
            &amp;row.executionStatus,
            &amp;row.queryCount,
            &amp;row.avgExecutionTime,
            &amp;row.avgBytesScanned,
            &amp;row.avgBytesWritten,
            &amp;row.avgRowsProduced,
            &amp;row.avgCompilationTime,
        ); err != nil </span><span class="cov0" title="0">{
            return fmt.Errorf("failed to scan query history row: %w", err)
        }</span>
        <span class="cov8" title="1">metrics.queryStats = append(metrics.queryStats, row)</span>
    }
    
    <span class="cov8" title="1">return rows.Err()</span>
}

func (c *snowflakeClient) queryCreditUsage(ctx context.Context, metrics *snowflakeMetrics) error <span class="cov8" title="1">{
    query := `
        SELECT 
            WAREHOUSE_NAME,
            SUM(CREDITS_USED) as TOTAL_CREDITS,
            SUM(CREDITS_USED_COMPUTE) as COMPUTE_CREDITS,
            SUM(CREDITS_USED_CLOUD_SERVICES) as CLOUD_SERVICE_CREDITS
        FROM SNOWFLAKE.ACCOUNT_USAGE.WAREHOUSE_METERING_HISTORY
        WHERE START_TIME &gt;= DATEADD(hour, -1, CURRENT_TIMESTAMP())
        GROUP BY WAREHOUSE_NAME
    `
    
    rows, err := c.db.QueryContext(ctx, query)
    if err != nil </span><span class="cov8" title="1">{
        return fmt.Errorf("failed to query credit usage: %w", err)
    }</span>
    <span class="cov8" title="1">defer rows.Close()
    
    for rows.Next() </span><span class="cov8" title="1">{
        var row creditUsageRow
        if err := rows.Scan(
            &amp;row.warehouseName,
            &amp;row.totalCredits,
            &amp;row.computeCredits,
            &amp;row.cloudServiceCredits,
        ); err != nil </span><span class="cov0" title="0">{
            return fmt.Errorf("failed to scan credit usage row: %w", err)
        }</span>
        <span class="cov8" title="1">metrics.creditUsage = append(metrics.creditUsage, row)</span>
    }
    
    <span class="cov8" title="1">return rows.Err()</span>
}

func (c *snowflakeClient) queryStorageUsage(ctx context.Context, metrics *snowflakeMetrics) error <span class="cov8" title="1">{
    query := `
        SELECT 
            AVG(STORAGE_BYTES + STAGE_BYTES + FAILSAFE_BYTES) as TOTAL_STORAGE_BYTES,
            AVG(STAGE_BYTES) as STAGE_BYTES,
            AVG(FAILSAFE_BYTES) as FAILSAFE_BYTES
        FROM SNOWFLAKE.ACCOUNT_USAGE.STORAGE_USAGE
        WHERE USAGE_DATE &gt;= DATEADD(day, -1, CURRENT_DATE())
    `
    
    rows, err := c.db.QueryContext(ctx, query)
    if err != nil </span><span class="cov8" title="1">{
        return fmt.Errorf("failed to query storage usage: %w", err)
    }</span>
    <span class="cov8" title="1">defer rows.Close()
    
    if rows.Next() </span><span class="cov8" title="1">{
        var row storageUsageRow
        if err := rows.Scan(
            &amp;row.totalStorageBytes,
            &amp;row.stageBytes,
            &amp;row.failsafeBytes,
        ); err != nil </span><span class="cov0" title="0">{
            return fmt.Errorf("failed to scan storage usage row: %w", err)
        }</span>
        <span class="cov8" title="1">metrics.storageUsage = append(metrics.storageUsage, row)</span>
    }
    
    <span class="cov8" title="1">return rows.Err()</span>
}

func (c *snowflakeClient) queryLoginHistory(ctx context.Context, metrics *snowflakeMetrics) error <span class="cov8" title="1">{
    query := `
        SELECT 
            IS_SUCCESS,
            ERROR_CODE,
            COUNT(*) as LOGIN_COUNT
        FROM SNOWFLAKE.ACCOUNT_USAGE.LOGIN_HISTORY
        WHERE EVENT_TIMESTAMP &gt;= DATEADD(hour, -1, CURRENT_TIMESTAMP())
        GROUP BY IS_SUCCESS, ERROR_CODE
    `
    
    rows, err := c.db.QueryContext(ctx, query)
    if err != nil </span><span class="cov8" title="1">{
        return fmt.Errorf("failed to query login history: %w", err)
    }</span>
    <span class="cov8" title="1">defer rows.Close()
    
    for rows.Next() </span><span class="cov8" title="1">{
        var row loginHistoryRow
        if err := rows.Scan(
            &amp;row.isSuccess,
            &amp;row.errorCode,
            &amp;row.loginCount,
        ); err != nil </span><span class="cov0" title="0">{
            return fmt.Errorf("failed to scan login history row: %w", err)
        }</span>
        <span class="cov8" title="1">metrics.loginHistory = append(metrics.loginHistory, row)</span>
    }
    
    <span class="cov8" title="1">return rows.Err()</span>
}

func (c *snowflakeClient) queryPipeUsage(ctx context.Context, metrics *snowflakeMetrics) error <span class="cov8" title="1">{
    query := `
        SELECT 
            PIPE_NAME,
            SUM(CREDITS_USED) as TOTAL_CREDITS,
            SUM(BYTES_INSERTED) as BYTES_INSERTED,
            SUM(FILES_INSERTED) as FILES_INSERTED
        FROM SNOWFLAKE.ACCOUNT_USAGE.PIPE_USAGE_HISTORY
        WHERE START_TIME &gt;= DATEADD(hour, -1, CURRENT_TIMESTAMP())
        GROUP BY PIPE_NAME
    `
    
    rows, err := c.db.QueryContext(ctx, query)
    if err != nil </span><span class="cov8" title="1">{
        return fmt.Errorf("failed to query pipe usage: %w", err)
    }</span>
    <span class="cov8" title="1">defer rows.Close()
    
    for rows.Next() </span><span class="cov8" title="1">{
        var row pipeUsageRow
        if err := rows.Scan(
            &amp;row.pipeName,
            &amp;row.totalCredits,
            &amp;row.bytesInserted,
            &amp;row.filesInserted,
        ); err != nil </span><span class="cov0" title="0">{
            return fmt.Errorf("failed to scan pipe usage row: %w", err)
        }</span>
        <span class="cov8" title="1">metrics.pipeUsage = append(metrics.pipeUsage, row)</span>
    }
    
    <span class="cov8" title="1">return rows.Err()</span>
}

func (c *snowflakeClient) queryDatabaseStorage(ctx context.Context, metrics *snowflakeMetrics) error <span class="cov8" title="1">{
    query := `
        SELECT 
            DATABASE_NAME,
            AVG(AVERAGE_DATABASE_BYTES) as AVG_DATABASE_BYTES,
            AVG(AVERAGE_FAILSAFE_BYTES) as AVG_FAILSAFE_BYTES
        FROM SNOWFLAKE.ACCOUNT_USAGE.DATABASE_STORAGE_USAGE_HISTORY
        WHERE USAGE_DATE &gt;= DATEADD(day, -1, CURRENT_DATE())
        GROUP BY DATABASE_NAME
    `
    
    rows, err := c.db.QueryContext(ctx, query)
    if err != nil </span><span class="cov8" title="1">{
        return fmt.Errorf("failed to query database storage: %w", err)
    }</span>
    <span class="cov8" title="1">defer rows.Close()
    
    for rows.Next() </span><span class="cov8" title="1">{
        var row databaseStorageRow
        if err := rows.Scan(
            &amp;row.databaseName,
            &amp;row.avgDatabaseBytes,
            &amp;row.avgFailsafeBytes,
        ); err != nil </span><span class="cov0" title="0">{
            return fmt.Errorf("failed to scan database storage row: %w", err)
        }</span>
        <span class="cov8" title="1">metrics.databaseStorage = append(metrics.databaseStorage, row)</span>
    }
    
    <span class="cov8" title="1">return rows.Err()</span>
}

func (c *snowflakeClient) queryTaskHistory(ctx context.Context, metrics *snowflakeMetrics) error <span class="cov8" title="1">{
    // FIX: Use DATEDIFF to calculate execution time (COMPLETED_TIME - SCHEDULED_TIME)
    query := `
        SELECT 
            DATABASE_NAME,
            SCHEMA_NAME,
            NAME as TASK_NAME,
            STATE,
            COUNT(*) as EXECUTION_COUNT,
            AVG(DATEDIFF(MILLISECOND, SCHEDULED_TIME, COMPLETED_TIME)) as AVG_EXECUTION_TIME
        FROM SNOWFLAKE.ACCOUNT_USAGE.TASK_HISTORY
        WHERE SCHEDULED_TIME &gt;= DATEADD(hour, -1, CURRENT_TIMESTAMP())
          AND COMPLETED_TIME IS NOT NULL
        GROUP BY DATABASE_NAME, SCHEMA_NAME, NAME, STATE
    `
    
    rows, err := c.db.QueryContext(ctx, query)
    if err != nil </span><span class="cov8" title="1">{
        return fmt.Errorf("failed to query task history: %w", err)
    }</span>
    <span class="cov8" title="1">defer rows.Close()
    
    for rows.Next() </span><span class="cov8" title="1">{
        var row taskHistoryRow
        if err := rows.Scan(
            &amp;row.databaseName,
            &amp;row.schemaName,
            &amp;row.taskName,
            &amp;row.state,
            &amp;row.executionCount,
            &amp;row.avgExecutionTime,
        ); err != nil </span><span class="cov0" title="0">{
            return fmt.Errorf("failed to scan task history row: %w", err)
        }</span>
        <span class="cov8" title="1">metrics.taskHistory = append(metrics.taskHistory, row)</span>
    }
    
    <span class="cov8" title="1">return rows.Err()</span>
}

func (c *snowflakeClient) queryReplicationUsage(ctx context.Context, metrics *snowflakeMetrics) error <span class="cov8" title="1">{
    query := `
        SELECT 
            DATABASE_NAME,
            SUM(CREDITS_USED) as TOTAL_CREDITS,
            SUM(BYTES_TRANSFERRED) as BYTES_TRANSFERRED
        FROM SNOWFLAKE.ACCOUNT_USAGE.REPLICATION_USAGE_HISTORY
        WHERE START_TIME &gt;= DATEADD(hour, -1, CURRENT_TIMESTAMP())
        GROUP BY DATABASE_NAME
    `
    
    rows, err := c.db.QueryContext(ctx, query)
    if err != nil </span><span class="cov8" title="1">{
        return fmt.Errorf("failed to query replication usage: %w", err)
    }</span>
    <span class="cov8" title="1">defer rows.Close()
    
    for rows.Next() </span><span class="cov8" title="1">{
        var row replicationUsageRow
        if err := rows.Scan(
            &amp;row.databaseName,
            &amp;row.totalCredits,
            &amp;row.bytesTransferred,
        ); err != nil </span><span class="cov0" title="0">{
            return fmt.Errorf("failed to scan replication usage row: %w", err)
        }</span>
        <span class="cov8" title="1">metrics.replicationUsage = append(metrics.replicationUsage, row)</span>
    }
    
    <span class="cov8" title="1">return rows.Err()</span>
}

func (c *snowflakeClient) queryAutoClusteringHistory(ctx context.Context, metrics *snowflakeMetrics) error <span class="cov8" title="1">{
    // FIX: Use NUM_BYTES_RECLUSTERED and NUM_ROWS_RECLUSTERED (correct column names)
    query := `
        SELECT 
            DATABASE_NAME,
            SCHEMA_NAME,
            TABLE_NAME,
            SUM(CREDITS_USED) as TOTAL_CREDITS,
            SUM(NUM_BYTES_RECLUSTERED) as BYTES_RECLUSTERED,
            SUM(NUM_ROWS_RECLUSTERED) as ROWS_RECLUSTERED
        FROM SNOWFLAKE.ACCOUNT_USAGE.AUTOMATIC_CLUSTERING_HISTORY
        WHERE START_TIME &gt;= DATEADD(hour, -1, CURRENT_TIMESTAMP())
        GROUP BY DATABASE_NAME, SCHEMA_NAME, TABLE_NAME
    `
    
    rows, err := c.db.QueryContext(ctx, query)
    if err != nil </span><span class="cov8" title="1">{
        return fmt.Errorf("failed to query auto-clustering history: %w", err)
    }</span>
    <span class="cov8" title="1">defer rows.Close()
    
    for rows.Next() </span><span class="cov8" title="1">{
        var row autoClusteringRow
        if err := rows.Scan(
            &amp;row.databaseName,
            &amp;row.schemaName,
            &amp;row.tableName,
            &amp;row.totalCredits,
            &amp;row.bytesReclustered,
            &amp;row.rowsReclustered,
        ); err != nil </span><span class="cov0" title="0">{
            return fmt.Errorf("failed to scan auto-clustering row: %w", err)
        }</span>
        <span class="cov8" title="1">metrics.autoClusteringHistory = append(metrics.autoClusteringHistory, row)</span>
    }
    
    <span class="cov8" title="1">return rows.Err()</span>
}

func (c *snowflakeClient) queryEventTableLogs(ctx context.Context, metrics *snowflakeMetrics, eventType string) error <span class="cov8" title="1">{
    if c.config.EventTables.TableName == "" </span><span class="cov8" title="1">{
        return fmt.Errorf("event table name not configured")
    }</span>
    
    <span class="cov8" title="1">query := fmt.Sprintf(`
        SELECT 
            RESOURCE_ATTRIBUTES['snow.event.type']::STRING as EVENT_TYPE,
            SEVERITY_TEXT,
            RECORD['error.message']::STRING as ERROR_MESSAGE
        FROM %s
        WHERE TIMESTAMP &gt;= DATEADD(minute, -5, CURRENT_TIMESTAMP())
          AND RESOURCE_ATTRIBUTES['snow.event.type']::STRING = '%s'
        LIMIT 1000
    `, c.config.EventTables.TableName, eventType)
    
    rows, err := c.db.QueryContext(ctx, query)
    if err != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("failed to query event table logs: %w", err)
    }</span>
    <span class="cov8" title="1">defer rows.Close()
    
    var events []eventTableRow
    for rows.Next() </span><span class="cov8" title="1">{
        var row eventTableRow
        if err := rows.Scan(
            &amp;row.eventType,
            &amp;row.severity,
            &amp;row.errorMessage,
        ); err != nil </span><span class="cov0" title="0">{
            return fmt.Errorf("failed to scan event table row: %w", err)
        }</span>
        <span class="cov8" title="1">events = append(events, row)</span>
    }
    
    <span class="cov8" title="1">switch eventType </span>{
    case "QUERY":<span class="cov8" title="1">
        metrics.eventQueryLogs = events</span>
    case "TASK":<span class="cov0" title="0">
        metrics.eventTaskLogs = events</span>
    case "FUNCTION":<span class="cov0" title="0">
        metrics.eventFunctionLogs = events</span>
    case "PROCEDURE":<span class="cov0" title="0">
        metrics.eventProcedureLogs = events</span>
    }
    
    <span class="cov8" title="1">return rows.Err()</span>
}

func (c *snowflakeClient) queryOrgCreditUsage(ctx context.Context, metrics *snowflakeMetrics) error <span class="cov8" title="1">{
    cols := c.config.Organization.OrgCreditUsage.Columns
    
    query := fmt.Sprintf(`
        SELECT 
            %s as ORGANIZATION_NAME,
            %s as ACCOUNT_NAME,
            %s as SERVICE_TYPE,
            SUM(%s) as TOTAL_CREDITS
        FROM SNOWFLAKE.ORGANIZATION_USAGE.USAGE_IN_CURRENCY_DAILY
        WHERE %s &gt;= DATEADD(day, -1, CURRENT_DATE())
        GROUP BY %s, %s, %s
    `,
        cols.GetOrganizationName(),
        cols.GetAccountName(),
        cols.GetServiceType(),
        cols.GetCreditsUsed(),
        cols.GetUsageDate(),
        cols.GetOrganizationName(),
        cols.GetAccountName(),
        cols.GetServiceType(),
    )
    
    rows, err := c.db.QueryContext(ctx, query)
    if err != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("failed to query org credit usage: %w", err)
    }</span>
    <span class="cov8" title="1">defer rows.Close()
    
    for rows.Next() </span><span class="cov8" title="1">{
        var row orgCreditUsageRow
        if err := rows.Scan(
            &amp;row.organizationName,
            &amp;row.accountName,
            &amp;row.serviceType,
            &amp;row.totalCredits,
        ); err != nil </span><span class="cov0" title="0">{
            return fmt.Errorf("failed to scan org credit usage row: %w", err)
        }</span>
        <span class="cov8" title="1">metrics.orgCreditUsage = append(metrics.orgCreditUsage, row)</span>
    }
    
    <span class="cov8" title="1">return rows.Err()</span>
}

func (c *snowflakeClient) queryOrgStorageUsage(ctx context.Context, metrics *snowflakeMetrics) error <span class="cov8" title="1">{
    cols := c.config.Organization.OrgStorageUsage.Columns
    
    query := fmt.Sprintf(`
        SELECT 
            %s as ORGANIZATION_NAME,
            %s as ACCOUNT_NAME,
            AVG(%s) as AVG_STORAGE_BYTES,
            AVG(%s) as AVG_STAGE_BYTES,
            AVG(%s) as AVG_FAILSAFE_BYTES
        FROM SNOWFLAKE.ORGANIZATION_USAGE.STORAGE_DAILY_HISTORY
        WHERE %s &gt;= DATEADD(day, -1, CURRENT_DATE())
        GROUP BY %s, %s
    `,
        cols.GetOrganizationName(),
        cols.GetAccountName(),
        cols.GetStorageBytes(),
        cols.GetStageBytes(),
        cols.GetFailsafeBytes(),
        cols.GetUsageDate(),
        cols.GetOrganizationName(),
        cols.GetAccountName(),
    )
    
    rows, err := c.db.QueryContext(ctx, query)
    if err != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("failed to query org storage usage: %w", err)
    }</span>
    <span class="cov8" title="1">defer rows.Close()
    
    for rows.Next() </span><span class="cov8" title="1">{
        var row orgStorageUsageRow
        if err := rows.Scan(
            &amp;row.organizationName,
            &amp;row.accountName,
            &amp;row.avgStorageBytes,
            &amp;row.avgStageBytes,
            &amp;row.avgFailsafeBytes,
        ); err != nil </span><span class="cov0" title="0">{
            return fmt.Errorf("failed to scan org storage usage row: %w", err)
        }</span>
        <span class="cov8" title="1">metrics.orgStorageUsage = append(metrics.orgStorageUsage, row)</span>
    }
    
    <span class="cov8" title="1">return rows.Err()</span>
}

func (c *snowflakeClient) queryOrgDataTransfer(ctx context.Context, metrics *snowflakeMetrics) error <span class="cov8" title="1">{
    cols := c.config.Organization.OrgDataTransfer.Columns
    
    query := fmt.Sprintf(`
        SELECT 
            %s as ORGANIZATION_NAME,
            %s as SOURCE_ACCOUNT_NAME,
            %s as TARGET_ACCOUNT_NAME,
            %s as SOURCE_REGION,
            %s as TARGET_REGION,
            SUM(%s) as TOTAL_BYTES_TRANSFERRED
        FROM SNOWFLAKE.ORGANIZATION_USAGE.DATA_TRANSFER_DAILY_HISTORY
        WHERE %s &gt;= DATEADD(day, -1, CURRENT_DATE())
        GROUP BY %s, %s, %s, %s, %s
    `,
        cols.GetOrganizationName(),
        cols.GetSourceAccountName(),
        cols.GetTargetAccountName(),
        cols.GetSourceRegion(),
        cols.GetTargetRegion(),
        cols.GetBytesTransferred(),
        cols.GetTransferDate(),
        cols.GetOrganizationName(),
        cols.GetSourceAccountName(),
        cols.GetTargetAccountName(),
        cols.GetSourceRegion(),
        cols.GetTargetRegion(),
    )
    
    rows, err := c.db.QueryContext(ctx, query)
    if err != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("failed to query org data transfer: %w", err)
    }</span>
    <span class="cov8" title="1">defer rows.Close()
    
    for rows.Next() </span><span class="cov8" title="1">{
        var row orgDataTransferRow
        if err := rows.Scan(
            &amp;row.organizationName,
            &amp;row.sourceAccountName,
            &amp;row.targetAccountName,
            &amp;row.sourceRegion,
            &amp;row.targetRegion,
            &amp;row.totalBytesTransferred,
        ); err != nil </span><span class="cov0" title="0">{
            return fmt.Errorf("failed to scan org data transfer row: %w", err)
        }</span>
        <span class="cov8" title="1">metrics.orgDataTransfer = append(metrics.orgDataTransfer, row)</span>
    }
    
    <span class="cov8" title="1">return rows.Err()</span>
}

func (c *snowflakeClient) queryOrgContractUsage(ctx context.Context, metrics *snowflakeMetrics) error <span class="cov8" title="1">{
    cols := c.config.Organization.OrgContractUsage.Columns
    
    query := fmt.Sprintf(`
        SELECT 
            %s as ORGANIZATION_NAME,
            %s as CONTRACT_NUMBER,
            SUM(%s) as TOTAL_CREDITS_USED,
            SUM(%s) as TOTAL_CREDITS_BILLED
        FROM SNOWFLAKE.ORGANIZATION_USAGE.CONTRACT_ITEMS
        WHERE %s &gt;= DATEADD(day, -1, CURRENT_DATE())
        GROUP BY %s, %s
    `,
        cols.GetOrganizationName(),
        cols.GetContractNumber(),
        cols.GetCreditsUsed(),
        cols.GetCreditsBilled(),
        cols.GetUsageDate(),
        cols.GetOrganizationName(),
        cols.GetContractNumber(),
    )
    
    rows, err := c.db.QueryContext(ctx, query)
    if err != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("failed to query org contract usage: %w", err)
    }</span>
    <span class="cov8" title="1">defer rows.Close()
    
    for rows.Next() </span><span class="cov8" title="1">{
        var row orgContractUsageRow
        if err := rows.Scan(
            &amp;row.organizationName,
            &amp;row.contractNumber,
            &amp;row.totalCreditsUsed,
            &amp;row.totalCreditsBilled,
        ); err != nil </span><span class="cov0" title="0">{
            return fmt.Errorf("failed to scan org contract usage row: %w", err)
        }</span>
        <span class="cov8" title="1">metrics.orgContractUsage = append(metrics.orgContractUsage, row)</span>
    }
    
    <span class="cov8" title="1">return rows.Err()</span>
}

func (c *snowflakeClient) executeCustomQuery(ctx context.Context, metrics *snowflakeMetrics, query *CustomQuery) error <span class="cov8" title="1">{
    rows, err := c.db.QueryContext(ctx, query.SQL)
    if err != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("failed to execute custom query %s: %w", query.Name, err)
    }</span>
    <span class="cov8" title="1">defer rows.Close()
    
    columns, err := rows.Columns()
    if err != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("failed to get columns for custom query %s: %w", query.Name, err)
    }</span>
    
    <span class="cov8" title="1">var resultRows []map[string]interface{}
    
    for rows.Next() </span><span class="cov8" title="1">{
        values := make([]interface{}, len(columns))
        valuePtrs := make([]interface{}, len(columns))
        for i := range values </span><span class="cov8" title="1">{
            valuePtrs[i] = &amp;values[i]
        }</span>
        
        <span class="cov8" title="1">if err := rows.Scan(valuePtrs...); err != nil </span><span class="cov0" title="0">{
            return fmt.Errorf("failed to scan custom query row: %w", err)
        }</span>
        
        <span class="cov8" title="1">row := make(map[string]interface{})
        for i, col := range columns </span><span class="cov8" title="1">{
            row[col] = values[i]
        }</span>
        <span class="cov8" title="1">resultRows = append(resultRows, row)</span>
    }
    
    <span class="cov8" title="1">metrics.customQueryResults = append(metrics.customQueryResults, customQueryResult{
        name:       query.Name,
        metricType: query.MetricType,
        rows:       resultRows,
    })
    
    return rows.Err()</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package snowflakereceiver

import (
    "fmt"
    "time"
    
    "go.opentelemetry.io/collector/component"
)

// Config represents the receiver configuration
type Config struct {
    User           string                `mapstructure:"user"`
    Password       string                `mapstructure:"password"`
    Account        string                `mapstructure:"account"`
    Warehouse      string                `mapstructure:"warehouse"`
    Database       string                `mapstructure:"database"`
    Schema         string                `mapstructure:"schema"`
    Metrics        MetricsConfig         `mapstructure:"metrics"`
    EventTables    EventTablesConfig     `mapstructure:"event_tables"`
    Organization   OrganizationConfig    `mapstructure:"organization"`
    CustomQueries  CustomQueriesConfig   `mapstructure:"custom_queries"`
}

// Metrics configuration with per-metric intervals
type MetricsConfig struct {
    CurrentQueries        MetricCategoryConfig `mapstructure:"current_queries"`
    WarehouseLoad         MetricCategoryConfig `mapstructure:"warehouse_load"`
    QueryHistory          MetricCategoryConfig `mapstructure:"query_history"`
    CreditUsage           MetricCategoryConfig `mapstructure:"credit_usage"`
    StorageMetrics        MetricCategoryConfig `mapstructure:"storage_metrics"`
    LoginHistory          MetricCategoryConfig `mapstructure:"login_history"`
    DataPipeline          MetricCategoryConfig `mapstructure:"data_pipeline"`
    DatabaseStorage       MetricCategoryConfig `mapstructure:"database_storage"`
    TaskHistory           MetricCategoryConfig `mapstructure:"task_history"`
    ReplicationUsage      MetricCategoryConfig `mapstructure:"replication_usage"`
    AutoClusteringHistory MetricCategoryConfig `mapstructure:"auto_clustering_history"`
}

type MetricCategoryConfig struct {
    Enabled  bool   `mapstructure:"enabled"`
    Interval string `mapstructure:"interval"`
}

func (c *MetricCategoryConfig) GetInterval(defaultInterval time.Duration) time.Duration <span class="cov8" title="1">{
    if c.Interval == "" </span><span class="cov8" title="1">{
        return defaultInterval
    }</span>
    <span class="cov8" title="1">duration, err := time.ParseDuration(c.Interval)
    if err != nil </span><span class="cov8" title="1">{
        return defaultInterval
    }</span>
    <span class="cov8" title="1">return duration</span>
}

// Event Tables configuration
type EventTablesConfig struct {
    Enabled        bool                 `mapstructure:"enabled"`
    TableName      string               `mapstructure:"table_name"`
    QueryLogs      MetricCategoryConfig `mapstructure:"query_logs"`
    TaskLogs       MetricCategoryConfig `mapstructure:"task_logs"`
    FunctionLogs   MetricCategoryConfig `mapstructure:"function_logs"`
    ProcedureLogs  MetricCategoryConfig `mapstructure:"procedure_logs"`
}

// Organization metrics configuration with column mapping
type OrganizationConfig struct {
    Enabled           bool                       `mapstructure:"enabled"`
    OrgCreditUsage    OrgCreditUsageConfig       `mapstructure:"org_credit_usage"`
    OrgStorageUsage   OrgStorageUsageConfig      `mapstructure:"org_storage_usage"`
    OrgDataTransfer   OrgDataTransferConfig      `mapstructure:"org_data_transfer"`
    OrgContractUsage  OrgContractUsageConfig     `mapstructure:"org_contract_usage"`
}

type OrgCreditUsageConfig struct {
    Enabled  bool                    `mapstructure:"enabled"`
    Interval string                  `mapstructure:"interval"`
    Columns  OrgCreditUsageColumns   `mapstructure:"columns"`
}

type OrgCreditUsageColumns struct {
    OrganizationName string `mapstructure:"organization_name"`
    AccountName      string `mapstructure:"account_name"`
    ServiceType      string `mapstructure:"service_type"`
    CreditsUsed      string `mapstructure:"credits_used"`
    UsageDate        string `mapstructure:"usage_date"`
}

func (c *OrgCreditUsageConfig) GetInterval(defaultInterval time.Duration) time.Duration <span class="cov8" title="1">{
    if c.Interval == "" </span><span class="cov0" title="0">{
        return defaultInterval
    }</span>
    <span class="cov8" title="1">duration, err := time.ParseDuration(c.Interval)
    if err != nil </span><span class="cov0" title="0">{
        return defaultInterval
    }</span>
    <span class="cov8" title="1">return duration</span>
}

// Default column names for org credit usage
func (c *OrgCreditUsageColumns) GetOrganizationName() string <span class="cov8" title="1">{
    if c.OrganizationName != "" </span><span class="cov0" title="0">{
        return c.OrganizationName
    }</span>
    <span class="cov8" title="1">return "ORGANIZATION_NAME"</span>
}

func (c *OrgCreditUsageColumns) GetAccountName() string <span class="cov8" title="1">{
    if c.AccountName != "" </span><span class="cov0" title="0">{
        return c.AccountName
    }</span>
    <span class="cov8" title="1">return "ACCOUNT_NAME"</span>
}

func (c *OrgCreditUsageColumns) GetServiceType() string <span class="cov8" title="1">{
    if c.ServiceType != "" </span><span class="cov0" title="0">{
        return c.ServiceType
    }</span>
    <span class="cov8" title="1">return "SERVICE_TYPE"</span>
}

func (c *OrgCreditUsageColumns) GetCreditsUsed() string <span class="cov8" title="1">{
    if c.CreditsUsed != "" </span><span class="cov0" title="0">{
        return c.CreditsUsed
    }</span>
    <span class="cov8" title="1">return "CREDITS"</span>
}

func (c *OrgCreditUsageColumns) GetUsageDate() string <span class="cov8" title="1">{
    if c.UsageDate != "" </span><span class="cov0" title="0">{
        return c.UsageDate
    }</span>
    <span class="cov8" title="1">return "USAGE_DATE"</span>
}

type OrgStorageUsageConfig struct {
    Enabled  bool                      `mapstructure:"enabled"`
    Interval string                    `mapstructure:"interval"`
    Columns  OrgStorageUsageColumns    `mapstructure:"columns"`
}

type OrgStorageUsageColumns struct {
    OrganizationName string `mapstructure:"organization_name"`
    AccountName      string `mapstructure:"account_name"`
    StorageBytes     string `mapstructure:"storage_bytes"`
    StageBytes       string `mapstructure:"stage_bytes"`
    FailsafeBytes    string `mapstructure:"failsafe_bytes"`
    UsageDate        string `mapstructure:"usage_date"`
}

func (c *OrgStorageUsageConfig) GetInterval(defaultInterval time.Duration) time.Duration <span class="cov8" title="1">{
    if c.Interval == "" </span><span class="cov0" title="0">{
        return defaultInterval
    }</span>
    <span class="cov8" title="1">duration, err := time.ParseDuration(c.Interval)
    if err != nil </span><span class="cov0" title="0">{
        return defaultInterval
    }</span>
    <span class="cov8" title="1">return duration</span>
}

func (c *OrgStorageUsageColumns) GetOrganizationName() string <span class="cov8" title="1">{
    if c.OrganizationName != "" </span><span class="cov0" title="0">{
        return c.OrganizationName
    }</span>
    <span class="cov8" title="1">return "ORGANIZATION_NAME"</span>
}

func (c *OrgStorageUsageColumns) GetAccountName() string <span class="cov8" title="1">{
    if c.AccountName != "" </span><span class="cov0" title="0">{
        return c.AccountName
    }</span>
    <span class="cov8" title="1">return "ACCOUNT_NAME"</span>
}

func (c *OrgStorageUsageColumns) GetStorageBytes() string <span class="cov8" title="1">{
    if c.StorageBytes != "" </span><span class="cov0" title="0">{
        return c.StorageBytes
    }</span>
    <span class="cov8" title="1">return "AVERAGE_STORAGE_BYTES"</span>
}

func (c *OrgStorageUsageColumns) GetStageBytes() string <span class="cov8" title="1">{
    if c.StageBytes != "" </span><span class="cov0" title="0">{
        return c.StageBytes
    }</span>
    <span class="cov8" title="1">return "AVERAGE_STAGE_BYTES"</span>
}

func (c *OrgStorageUsageColumns) GetFailsafeBytes() string <span class="cov8" title="1">{
    if c.FailsafeBytes != "" </span><span class="cov0" title="0">{
        return c.FailsafeBytes
    }</span>
    <span class="cov8" title="1">return "AVERAGE_FAILSAFE_BYTES"</span>
}

func (c *OrgStorageUsageColumns) GetUsageDate() string <span class="cov8" title="1">{
    if c.UsageDate != "" </span><span class="cov0" title="0">{
        return c.UsageDate
    }</span>
    <span class="cov8" title="1">return "USAGE_DATE"</span>
}

type OrgDataTransferConfig struct {
    Enabled  bool                      `mapstructure:"enabled"`
    Interval string                    `mapstructure:"interval"`
    Columns  OrgDataTransferColumns    `mapstructure:"columns"`
}

type OrgDataTransferColumns struct {
    OrganizationName  string `mapstructure:"organization_name"`
    SourceAccountName string `mapstructure:"source_account_name"`
    TargetAccountName string `mapstructure:"target_account_name"`
    SourceRegion      string `mapstructure:"source_region"`
    TargetRegion      string `mapstructure:"target_region"`
    BytesTransferred  string `mapstructure:"bytes_transferred"`
    TransferDate      string `mapstructure:"transfer_date"`
}

func (c *OrgDataTransferConfig) GetInterval(defaultInterval time.Duration) time.Duration <span class="cov8" title="1">{
    if c.Interval == "" </span><span class="cov0" title="0">{
        return defaultInterval
    }</span>
    <span class="cov8" title="1">duration, err := time.ParseDuration(c.Interval)
    if err != nil </span><span class="cov0" title="0">{
        return defaultInterval
    }</span>
    <span class="cov8" title="1">return duration</span>
}

func (c *OrgDataTransferColumns) GetOrganizationName() string <span class="cov8" title="1">{
    if c.OrganizationName != "" </span><span class="cov0" title="0">{
        return c.OrganizationName
    }</span>
    <span class="cov8" title="1">return "ORGANIZATION_NAME"</span>
}

func (c *OrgDataTransferColumns) GetSourceAccountName() string <span class="cov8" title="1">{
    if c.SourceAccountName != "" </span><span class="cov0" title="0">{
        return c.SourceAccountName
    }</span>
    <span class="cov8" title="1">return "SOURCE_ACCOUNT_NAME"</span>
}

func (c *OrgDataTransferColumns) GetTargetAccountName() string <span class="cov8" title="1">{
    if c.TargetAccountName != "" </span><span class="cov0" title="0">{
        return c.TargetAccountName
    }</span>
    <span class="cov8" title="1">return "TARGET_ACCOUNT_NAME"</span>
}

func (c *OrgDataTransferColumns) GetSourceRegion() string <span class="cov8" title="1">{
    if c.SourceRegion != "" </span><span class="cov0" title="0">{
        return c.SourceRegion
    }</span>
    <span class="cov8" title="1">return "SOURCE_REGION"</span>
}

func (c *OrgDataTransferColumns) GetTargetRegion() string <span class="cov8" title="1">{
    if c.TargetRegion != "" </span><span class="cov0" title="0">{
        return c.TargetRegion
    }</span>
    <span class="cov8" title="1">return "TARGET_REGION"</span>
}

func (c *OrgDataTransferColumns) GetBytesTransferred() string <span class="cov8" title="1">{
    if c.BytesTransferred != "" </span><span class="cov0" title="0">{
        return c.BytesTransferred
    }</span>
    <span class="cov8" title="1">return "BYTES_TRANSFERRED"</span>
}

func (c *OrgDataTransferColumns) GetTransferDate() string <span class="cov8" title="1">{
    if c.TransferDate != "" </span><span class="cov0" title="0">{
        return c.TransferDate
    }</span>
    <span class="cov8" title="1">return "TRANSFER_DATE"</span>
}

type OrgContractUsageConfig struct {
    Enabled  bool                       `mapstructure:"enabled"`
    Interval string                     `mapstructure:"interval"`
    Columns  OrgContractUsageColumns    `mapstructure:"columns"`
}

type OrgContractUsageColumns struct {
    OrganizationName string `mapstructure:"organization_name"`
    ContractNumber   string `mapstructure:"contract_number"`
    CreditsUsed      string `mapstructure:"credits_used"`
    CreditsBilled    string `mapstructure:"credits_billed"`
    UsageDate        string `mapstructure:"usage_date"`
}

func (c *OrgContractUsageConfig) GetInterval(defaultInterval time.Duration) time.Duration <span class="cov8" title="1">{
    if c.Interval == "" </span><span class="cov0" title="0">{
        return defaultInterval
    }</span>
    <span class="cov8" title="1">duration, err := time.ParseDuration(c.Interval)
    if err != nil </span><span class="cov0" title="0">{
        return defaultInterval
    }</span>
    <span class="cov8" title="1">return duration</span>
}

func (c *OrgContractUsageColumns) GetOrganizationName() string <span class="cov8" title="1">{
    if c.OrganizationName != "" </span><span class="cov0" title="0">{
        return c.OrganizationName
    }</span>
    <span class="cov8" title="1">return "ORGANIZATION_NAME"</span>
}

func (c *OrgContractUsageColumns) GetContractNumber() string <span class="cov8" title="1">{
    if c.ContractNumber != "" </span><span class="cov0" title="0">{
        return c.ContractNumber
    }</span>
    <span class="cov8" title="1">return "CONTRACT_NUMBER"</span>
}

func (c *OrgContractUsageColumns) GetCreditsUsed() string <span class="cov8" title="1">{
    if c.CreditsUsed != "" </span><span class="cov0" title="0">{
        return c.CreditsUsed
    }</span>
    <span class="cov8" title="1">return "CREDITS_USED"</span>
}

func (c *OrgContractUsageColumns) GetCreditsBilled() string <span class="cov8" title="1">{
    if c.CreditsBilled != "" </span><span class="cov0" title="0">{
        return c.CreditsBilled
    }</span>
    <span class="cov8" title="1">return "CREDITS_BILLED"</span>
}

func (c *OrgContractUsageColumns) GetUsageDate() string <span class="cov8" title="1">{
    if c.UsageDate != "" </span><span class="cov0" title="0">{
        return c.UsageDate
    }</span>
    <span class="cov8" title="1">return "USAGE_DATE"</span>
}

// Custom queries configuration
type CustomQueriesConfig struct {
    Enabled bool          `mapstructure:"enabled"`
    Queries []CustomQuery `mapstructure:"queries"`
}

type CustomQuery struct {
    Name         string   `mapstructure:"name"`
    Interval     string   `mapstructure:"interval"`
    MetricType   string   `mapstructure:"metric_type"`
    ValueColumn  string   `mapstructure:"value_column"`
    LabelColumns []string `mapstructure:"label_columns"`
    SQL          string   `mapstructure:"sql"`
}

func (q *CustomQuery) GetInterval(defaultInterval time.Duration) time.Duration <span class="cov8" title="1">{
    if q.Interval == "" </span><span class="cov0" title="0">{
        return defaultInterval
    }</span>
    <span class="cov8" title="1">duration, err := time.ParseDuration(q.Interval)
    if err != nil </span><span class="cov0" title="0">{
        return defaultInterval
    }</span>
    <span class="cov8" title="1">return duration</span>
}


// GetBaseInterval returns the minimum interval across all enabled metrics
func (cfg *Config) GetBaseInterval() time.Duration <span class="cov8" title="1">{
    minInterval := 30 * time.Second
    
    allMetrics := []MetricCategoryConfig{
        cfg.Metrics.CurrentQueries,
        cfg.Metrics.WarehouseLoad,
        cfg.Metrics.QueryHistory,
        cfg.Metrics.CreditUsage,
        cfg.Metrics.StorageMetrics,
        cfg.Metrics.LoginHistory,
        cfg.Metrics.DataPipeline,
        cfg.Metrics.DatabaseStorage,
        cfg.Metrics.TaskHistory,
        cfg.Metrics.ReplicationUsage,
        cfg.Metrics.AutoClusteringHistory,
    }
    
    if cfg.EventTables.Enabled </span><span class="cov8" title="1">{
        allMetrics = append(allMetrics,
            cfg.EventTables.QueryLogs,
            cfg.EventTables.TaskLogs,
            cfg.EventTables.FunctionLogs,
            cfg.EventTables.ProcedureLogs,
        )
    }</span>
    
    <span class="cov8" title="1">if cfg.Organization.Enabled </span><span class="cov8" title="1">{
        allMetrics = append(allMetrics,
            cfg.Organization.OrgCreditUsage.MetricCategoryConfig(),
            cfg.Organization.OrgStorageUsage.MetricCategoryConfig(),
            cfg.Organization.OrgDataTransfer.MetricCategoryConfig(),
            cfg.Organization.OrgContractUsage.MetricCategoryConfig(),
        )
    }</span>
    
    <span class="cov8" title="1">for _, metric := range allMetrics </span><span class="cov8" title="1">{
        if metric.Enabled &amp;&amp; metric.Interval != "" </span><span class="cov8" title="1">{
            interval := metric.GetInterval(minInterval)
            if interval &lt; minInterval </span><span class="cov8" title="1">{
                minInterval = interval
            }</span>
        }
    }
    
    <span class="cov8" title="1">return minInterval</span>
}

// Helper methods to convert org configs to MetricCategoryConfig
func (c *OrgCreditUsageConfig) MetricCategoryConfig() MetricCategoryConfig <span class="cov8" title="1">{
    return MetricCategoryConfig{Enabled: c.Enabled, Interval: c.Interval}
}</span>

func (c *OrgStorageUsageConfig) MetricCategoryConfig() MetricCategoryConfig <span class="cov8" title="1">{
    return MetricCategoryConfig{Enabled: c.Enabled, Interval: c.Interval}
}</span>

func (c *OrgDataTransferConfig) MetricCategoryConfig() MetricCategoryConfig <span class="cov8" title="1">{
    return MetricCategoryConfig{Enabled: c.Enabled, Interval: c.Interval}
}</span>

func (c *OrgContractUsageConfig) MetricCategoryConfig() MetricCategoryConfig <span class="cov8" title="1">{
    return MetricCategoryConfig{Enabled: c.Enabled, Interval: c.Interval}
}</span>

// createDefaultConfig creates the default configuration
func createDefaultConfig() component.Config <span class="cov8" title="1">{
    return &amp;Config{
        Database: "SNOWFLAKE",
        Schema:   "ACCOUNT_USAGE",
        Metrics: MetricsConfig{
            CurrentQueries:        MetricCategoryConfig{Enabled: true, Interval: "1m"},
            WarehouseLoad:         MetricCategoryConfig{Enabled: true, Interval: "1m"},
            QueryHistory:          MetricCategoryConfig{Enabled: true, Interval: "5m"},
            CreditUsage:           MetricCategoryConfig{Enabled: true, Interval: "5m"},
            StorageMetrics:        MetricCategoryConfig{Enabled: true, Interval: "30m"},
            LoginHistory:          MetricCategoryConfig{Enabled: true, Interval: "10m"},
            DataPipeline:          MetricCategoryConfig{Enabled: true, Interval: "10m"},
            DatabaseStorage:       MetricCategoryConfig{Enabled: true, Interval: "30m"},
            TaskHistory:           MetricCategoryConfig{Enabled: true, Interval: "10m"},
            ReplicationUsage:      MetricCategoryConfig{Enabled: true, Interval: "15m"},
            AutoClusteringHistory: MetricCategoryConfig{Enabled: true, Interval: "15m"},
        },
        EventTables: EventTablesConfig{
            Enabled:       false,
            QueryLogs:     MetricCategoryConfig{Enabled: true, Interval: "30s"},
            TaskLogs:      MetricCategoryConfig{Enabled: true, Interval: "30s"},
            FunctionLogs:  MetricCategoryConfig{Enabled: true, Interval: "30s"},
            ProcedureLogs: MetricCategoryConfig{Enabled: true, Interval: "30s"},
        },
        Organization: OrganizationConfig{
            Enabled: false,
            OrgCreditUsage: OrgCreditUsageConfig{
                Enabled:  true,
                Interval: "1h",
                Columns:  OrgCreditUsageColumns{},
            },
            OrgStorageUsage: OrgStorageUsageConfig{
                Enabled:  true,
                Interval: "1h",
                Columns:  OrgStorageUsageColumns{},
            },
            OrgDataTransfer: OrgDataTransferConfig{
                Enabled:  true,
                Interval: "1h",
                Columns:  OrgDataTransferColumns{},
            },
            OrgContractUsage: OrgContractUsageConfig{
                Enabled:  true,
                Interval: "12h",
                Columns:  OrgContractUsageColumns{},
            },
        },
        CustomQueries: CustomQueriesConfig{
            Enabled: false,
            Queries: []CustomQuery{},
        },
    }
}</span>

// Validate validates the configuration
func (cfg *Config) Validate() error <span class="cov8" title="1">{
    if cfg.User == "" </span><span class="cov8" title="1">{
        return fmt.Errorf("user is required")
    }</span>
    <span class="cov8" title="1">if cfg.Password == "" </span><span class="cov8" title="1">{
        return fmt.Errorf("password is required")
    }</span>
    <span class="cov8" title="1">if cfg.Account == "" </span><span class="cov8" title="1">{
        return fmt.Errorf("account is required")
    }</span>
    <span class="cov8" title="1">if cfg.Warehouse == "" </span><span class="cov8" title="1">{
        return fmt.Errorf("warehouse is required")
    }</span>
    <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package snowflakereceiver

import (
    "context"
    
    "go.opentelemetry.io/collector/component"
    "go.opentelemetry.io/collector/consumer"
    "go.opentelemetry.io/collector/receiver"
    "go.opentelemetry.io/collector/scraper"
    "go.opentelemetry.io/collector/scraper/scraperhelper"
)

const (
    typeStr = "snowflake"
)

var (
    typeVal = component.MustNewType(typeStr)
)

func NewFactory() receiver.Factory <span class="cov8" title="1">{
    return receiver.NewFactory(
        typeVal,
        createDefaultConfig,
        receiver.WithMetrics(createMetricsReceiver, component.StabilityLevelAlpha),
    )
}</span>

func createMetricsReceiver(
    ctx context.Context,
    settings receiver.Settings,
    cfg component.Config,
    consumer consumer.Metrics,
) (receiver.Metrics, error) <span class="cov8" title="1">{
    
    snowflakeCfg := cfg.(*Config)
    
    // Use the shortest interval as base scrape interval
    interval := snowflakeCfg.GetBaseInterval()
    
    s, err := newSnowflakeScraper(settings, snowflakeCfg)
    if err != nil </span><span class="cov0" title="0">{
        return nil, err
    }</span>
    
    <span class="cov8" title="1">scraperCfg := &amp;scraperhelper.ControllerConfig{
        CollectionInterval: interval,
        InitialDelay:       interval,
    }
    
    sc, err := scraper.NewMetrics(s.scrape)
    if err != nil </span><span class="cov0" title="0">{
        return nil, err
    }</span>
    
    <span class="cov8" title="1">return scraperhelper.NewMetricsController(
        scraperCfg,
        settings,
        consumer,
        scraperhelper.AddScraper(typeVal, sc),
    )</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package snowflakereceiver

import (
    "context"
    "fmt"
    "strconv"
    "time"
    
    "go.opentelemetry.io/collector/pdata/pcommon"
    "go.opentelemetry.io/collector/pdata/pmetric"
    "go.opentelemetry.io/collector/receiver"
    "go.uber.org/zap"
)

type snowflakeScraper struct {
    logger  *zap.Logger
    config  *Config
    client  *snowflakeClient
    lastRun map[string]time.Time
}

func newSnowflakeScraper(settings receiver.Settings, config *Config) (*snowflakeScraper, error) <span class="cov8" title="1">{
    client, err := newSnowflakeClient(settings.Logger, config)
    if err != nil </span><span class="cov0" title="0">{
        return nil, err
    }</span>
    
    <span class="cov8" title="1">return &amp;snowflakeScraper{
        logger:  settings.Logger,
        config:  config,
        client:  client,
        lastRun: make(map[string]time.Time),
    }, nil</span>
}

func (s *snowflakeScraper) shouldScrape(metricName string, interval time.Duration) bool <span class="cov8" title="1">{
    lastRun, exists := s.lastRun[metricName]
    if !exists </span><span class="cov8" title="1">{
        return true
    }</span>
    <span class="cov8" title="1">return time.Since(lastRun) &gt;= interval</span>
}

func (s *snowflakeScraper) markScraped(metricName string) <span class="cov8" title="1">{
    s.lastRun[metricName] = time.Now()
}</span>

func (s *snowflakeScraper) scrape(ctx context.Context) (pmetric.Metrics, error) <span class="cov0" title="0">{
    if err := s.client.connect(ctx); err != nil </span><span class="cov0" title="0">{
        s.logger.Error("Failed to connect to Snowflake", zap.Error(err))
        return pmetric.NewMetrics(), err
    }</span>
    
    <span class="cov0" title="0">metrics, err := s.client.queryMetrics(ctx)
    if err != nil </span><span class="cov0" title="0">{
        s.logger.Error("Failed to query Snowflake metrics", zap.Error(err))
        return pmetric.NewMetrics(), err
    }</span>
    
    <span class="cov0" title="0">return s.buildMetrics(metrics), nil</span>
}

func (s *snowflakeScraper) buildMetrics(metrics *snowflakeMetrics) pmetric.Metrics <span class="cov8" title="1">{
    md := pmetric.NewMetrics()
    resourceMetrics := md.ResourceMetrics().AppendEmpty()
    
    resourceAttrs := resourceMetrics.Resource().Attributes()
    resourceAttrs.PutStr("snowflake.account.name", s.config.Account)
    resourceAttrs.PutStr("snowflake.warehouse.name", s.config.Warehouse)
    resourceAttrs.PutStr("snowflake.database.name", s.config.Database)
    
    scopeMetrics := resourceMetrics.ScopeMetrics().AppendEmpty()
    now := pcommon.NewTimestampFromTime(time.Now())
    
    // Standard metrics with per-metric intervals
    if s.config.Metrics.CurrentQueries.Enabled &amp;&amp; len(metrics.currentQueries) &gt; 0 </span><span class="cov8" title="1">{
        interval := s.config.Metrics.CurrentQueries.GetInterval(1 * time.Minute)
        if s.shouldScrape("current_queries", interval) </span><span class="cov8" title="1">{
            s.addCurrentQueryMetrics(scopeMetrics, metrics.currentQueries, now)
            s.markScraped("current_queries")
        }</span>
    }
    
    <span class="cov8" title="1">if s.config.Metrics.WarehouseLoad.Enabled &amp;&amp; len(metrics.warehouseLoad) &gt; 0 </span><span class="cov0" title="0">{
        interval := s.config.Metrics.WarehouseLoad.GetInterval(1 * time.Minute)
        if s.shouldScrape("warehouse_load", interval) </span><span class="cov0" title="0">{
            s.addWarehouseLoadMetrics(scopeMetrics, metrics.warehouseLoad, now)
            s.markScraped("warehouse_load")
        }</span>
    }
    
    <span class="cov8" title="1">if s.config.Metrics.QueryHistory.Enabled &amp;&amp; len(metrics.queryStats) &gt; 0 </span><span class="cov0" title="0">{
        interval := s.config.Metrics.QueryHistory.GetInterval(5 * time.Minute)
        if s.shouldScrape("query_history", interval) </span><span class="cov0" title="0">{
            s.addQueryMetrics(scopeMetrics, metrics.queryStats, now)
            s.markScraped("query_history")
        }</span>
    }
    
    <span class="cov8" title="1">if s.config.Metrics.CreditUsage.Enabled &amp;&amp; len(metrics.creditUsage) &gt; 0 </span><span class="cov0" title="0">{
        interval := s.config.Metrics.CreditUsage.GetInterval(5 * time.Minute)
        if s.shouldScrape("credit_usage", interval) </span><span class="cov0" title="0">{
            s.addCreditMetrics(scopeMetrics, metrics.creditUsage, now)
            s.markScraped("credit_usage")
        }</span>
    }
    
    <span class="cov8" title="1">if s.config.Metrics.StorageMetrics.Enabled &amp;&amp; len(metrics.storageUsage) &gt; 0 </span><span class="cov0" title="0">{
        interval := s.config.Metrics.StorageMetrics.GetInterval(30 * time.Minute)
        if s.shouldScrape("storage_metrics", interval) </span><span class="cov0" title="0">{
            s.addStorageMetrics(scopeMetrics, metrics.storageUsage, now)
            s.markScraped("storage_metrics")
        }</span>
    }
    
    <span class="cov8" title="1">if s.config.Metrics.LoginHistory.Enabled &amp;&amp; len(metrics.loginHistory) &gt; 0 </span><span class="cov0" title="0">{
        interval := s.config.Metrics.LoginHistory.GetInterval(10 * time.Minute)
        if s.shouldScrape("login_history", interval) </span><span class="cov0" title="0">{
            s.addLoginMetrics(scopeMetrics, metrics.loginHistory, now)
            s.markScraped("login_history")
        }</span>
    }
    
    <span class="cov8" title="1">if s.config.Metrics.DataPipeline.Enabled &amp;&amp; len(metrics.pipeUsage) &gt; 0 </span><span class="cov0" title="0">{
        interval := s.config.Metrics.DataPipeline.GetInterval(10 * time.Minute)
        if s.shouldScrape("data_pipeline", interval) </span><span class="cov0" title="0">{
            s.addPipeMetrics(scopeMetrics, metrics.pipeUsage, now)
            s.markScraped("data_pipeline")
        }</span>
    }
    
    <span class="cov8" title="1">if s.config.Metrics.DatabaseStorage.Enabled &amp;&amp; len(metrics.databaseStorage) &gt; 0 </span><span class="cov0" title="0">{
        interval := s.config.Metrics.DatabaseStorage.GetInterval(30 * time.Minute)
        if s.shouldScrape("database_storage", interval) </span><span class="cov0" title="0">{
            s.addDatabaseStorageMetrics(scopeMetrics, metrics.databaseStorage, now)
            s.markScraped("database_storage")
        }</span>
    }
    
    <span class="cov8" title="1">if s.config.Metrics.TaskHistory.Enabled &amp;&amp; len(metrics.taskHistory) &gt; 0 </span><span class="cov0" title="0">{
        interval := s.config.Metrics.TaskHistory.GetInterval(10 * time.Minute)
        if s.shouldScrape("task_history", interval) </span><span class="cov0" title="0">{
            s.addTaskHistoryMetrics(scopeMetrics, metrics.taskHistory, now)
            s.markScraped("task_history")
        }</span>
    }
    
    <span class="cov8" title="1">if s.config.Metrics.ReplicationUsage.Enabled &amp;&amp; len(metrics.replicationUsage) &gt; 0 </span><span class="cov0" title="0">{
        interval := s.config.Metrics.ReplicationUsage.GetInterval(15 * time.Minute)
        if s.shouldScrape("replication_usage", interval) </span><span class="cov0" title="0">{
            s.addReplicationMetrics(scopeMetrics, metrics.replicationUsage, now)
            s.markScraped("replication_usage")
        }</span>
    }
    
    <span class="cov8" title="1">if s.config.Metrics.AutoClusteringHistory.Enabled &amp;&amp; len(metrics.autoClusteringHistory) &gt; 0 </span><span class="cov0" title="0">{
        interval := s.config.Metrics.AutoClusteringHistory.GetInterval(15 * time.Minute)
        if s.shouldScrape("auto_clustering_history", interval) </span><span class="cov0" title="0">{
            s.addAutoClusteringMetrics(scopeMetrics, metrics.autoClusteringHistory, now)
            s.markScraped("auto_clustering_history")
        }</span>
    }
    
    // EVENT TABLES - REAL-TIME (seconds latency!)
    <span class="cov8" title="1">if s.config.EventTables.Enabled </span><span class="cov0" title="0">{
        if s.config.EventTables.QueryLogs.Enabled &amp;&amp; len(metrics.eventQueryLogs) &gt; 0 </span><span class="cov0" title="0">{
            interval := s.config.EventTables.QueryLogs.GetInterval(30 * time.Second)
            if s.shouldScrape("event_query_logs", interval) </span><span class="cov0" title="0">{
                s.addEventTableMetrics(scopeMetrics, metrics.eventQueryLogs, now)
                s.markScraped("event_query_logs")
            }</span>
        }
        
        <span class="cov0" title="0">if s.config.EventTables.TaskLogs.Enabled &amp;&amp; len(metrics.eventTaskLogs) &gt; 0 </span><span class="cov0" title="0">{
            interval := s.config.EventTables.TaskLogs.GetInterval(30 * time.Second)
            if s.shouldScrape("event_task_logs", interval) </span><span class="cov0" title="0">{
                s.addEventTableMetrics(scopeMetrics, metrics.eventTaskLogs, now)
                s.markScraped("event_task_logs")
            }</span>
        }
        
        <span class="cov0" title="0">if s.config.EventTables.FunctionLogs.Enabled &amp;&amp; len(metrics.eventFunctionLogs) &gt; 0 </span><span class="cov0" title="0">{
            interval := s.config.EventTables.FunctionLogs.GetInterval(30 * time.Second)
            if s.shouldScrape("event_function_logs", interval) </span><span class="cov0" title="0">{
                s.addEventTableMetrics(scopeMetrics, metrics.eventFunctionLogs, now)
                s.markScraped("event_function_logs")
            }</span>
        }
        
        <span class="cov0" title="0">if s.config.EventTables.ProcedureLogs.Enabled &amp;&amp; len(metrics.eventProcedureLogs) &gt; 0 </span><span class="cov0" title="0">{
            interval := s.config.EventTables.ProcedureLogs.GetInterval(30 * time.Second)
            if s.shouldScrape("event_procedure_logs", interval) </span><span class="cov0" title="0">{
                s.addEventTableMetrics(scopeMetrics, metrics.eventProcedureLogs, now)
                s.markScraped("event_procedure_logs")
            }</span>
        }
    }
    
    // ORGANIZATION METRICS
    <span class="cov8" title="1">if s.config.Organization.Enabled </span><span class="cov0" title="0">{
        if s.config.Organization.OrgCreditUsage.Enabled &amp;&amp; len(metrics.orgCreditUsage) &gt; 0 </span><span class="cov0" title="0">{
            interval := s.config.Organization.OrgCreditUsage.GetInterval(1 * time.Hour)
            if s.shouldScrape("org_credit_usage", interval) </span><span class="cov0" title="0">{
                s.addOrgCreditMetrics(scopeMetrics, metrics.orgCreditUsage, now)
                s.markScraped("org_credit_usage")
            }</span>
        }
        
        <span class="cov0" title="0">if s.config.Organization.OrgStorageUsage.Enabled &amp;&amp; len(metrics.orgStorageUsage) &gt; 0 </span><span class="cov0" title="0">{
            interval := s.config.Organization.OrgStorageUsage.GetInterval(1 * time.Hour)
            if s.shouldScrape("org_storage_usage", interval) </span><span class="cov0" title="0">{
                s.addOrgStorageMetrics(scopeMetrics, metrics.orgStorageUsage, now)
                s.markScraped("org_storage_usage")
            }</span>
        }
        
        <span class="cov0" title="0">if s.config.Organization.OrgDataTransfer.Enabled &amp;&amp; len(metrics.orgDataTransfer) &gt; 0 </span><span class="cov0" title="0">{
            interval := s.config.Organization.OrgDataTransfer.GetInterval(1 * time.Hour)
            if s.shouldScrape("org_data_transfer", interval) </span><span class="cov0" title="0">{
                s.addOrgDataTransferMetrics(scopeMetrics, metrics.orgDataTransfer, now)
                s.markScraped("org_data_transfer")
            }</span>
        }
        
        <span class="cov0" title="0">if s.config.Organization.OrgContractUsage.Enabled &amp;&amp; len(metrics.orgContractUsage) &gt; 0 </span><span class="cov0" title="0">{
            interval := s.config.Organization.OrgContractUsage.GetInterval(12 * time.Hour)
            if s.shouldScrape("org_contract_usage", interval) </span><span class="cov0" title="0">{
                s.addOrgContractMetrics(scopeMetrics, metrics.orgContractUsage, now)
                s.markScraped("org_contract_usage")
            }</span>
        }
    }
    
    // CUSTOM QUERIES
    <span class="cov8" title="1">if s.config.CustomQueries.Enabled &amp;&amp; len(metrics.customQueryResults) &gt; 0 </span><span class="cov0" title="0">{
        for _, result := range metrics.customQueryResults </span><span class="cov0" title="0">{
            s.addCustomQueryMetrics(scopeMetrics, result, now)
        }</span>
    }
    
    <span class="cov8" title="1">return md</span>
}

// ========== INFORMATION_SCHEMA Metrics (REAL-TIME) ==========
// Metric naming: snowflake.queries.current.* (OTel conventions)

func (s *snowflakeScraper) addCurrentQueryMetrics(scopeMetrics pmetric.ScopeMetrics, queries []currentQueryRow, now pcommon.Timestamp) <span class="cov8" title="1">{
    for _, query := range queries </span><span class="cov8" title="1">{
        // Query count metric
        metric := scopeMetrics.Metrics().AppendEmpty()
        metric.SetName("snowflake.queries.current.count")
        metric.SetDescription("Current query count (last 5 minutes, REAL-TIME)")
        metric.SetUnit("{queries}")
        gauge := metric.SetEmptyGauge()
        dp := gauge.DataPoints().AppendEmpty()
        dp.SetTimestamp(now)
        dp.SetIntValue(query.queryCount)
        if query.warehouseName.Valid </span><span class="cov8" title="1">{
            dp.Attributes().PutStr("warehouse.name", query.warehouseName.String)
        }</span>
        <span class="cov8" title="1">if query.queryType.Valid </span><span class="cov8" title="1">{
            dp.Attributes().PutStr("query.type", query.queryType.String)
        }</span>
        <span class="cov8" title="1">if query.executionStatus.Valid </span><span class="cov8" title="1">{
            dp.Attributes().PutStr("execution.status", query.executionStatus.String)
        }</span>
        <span class="cov8" title="1">dp.Attributes().PutStr("data.source", "information_schema")
        
        // Execution time metric
        if query.avgExecutionTime.Valid </span><span class="cov8" title="1">{
            execMetric := scopeMetrics.Metrics().AppendEmpty()
            execMetric.SetName("snowflake.queries.current.execution.time")
            execMetric.SetDescription("Current query execution time (REAL-TIME)")
            execMetric.SetUnit("ms")
            execGauge := execMetric.SetEmptyGauge()
            execDp := execGauge.DataPoints().AppendEmpty()
            execDp.SetTimestamp(now)
            execDp.SetIntValue(int64(query.avgExecutionTime.Float64))
            if query.warehouseName.Valid </span><span class="cov8" title="1">{
                execDp.Attributes().PutStr("warehouse.name", query.warehouseName.String)
            }</span>
            <span class="cov8" title="1">if query.queryType.Valid </span><span class="cov8" title="1">{
                execDp.Attributes().PutStr("query.type", query.queryType.String)
            }</span>
            <span class="cov8" title="1">execDp.Attributes().PutStr("data.source", "information_schema")</span>
        }
        
        // Bytes scanned metric
        <span class="cov8" title="1">if query.avgBytesScanned.Valid </span><span class="cov8" title="1">{
            bytesMetric := scopeMetrics.Metrics().AppendEmpty()
            bytesMetric.SetName("snowflake.queries.current.bytes.scanned")
            bytesMetric.SetDescription("Current query bytes scanned (REAL-TIME)")
            bytesMetric.SetUnit("By")
            bytesGauge := bytesMetric.SetEmptyGauge()
            bytesDp := bytesGauge.DataPoints().AppendEmpty()
            bytesDp.SetTimestamp(now)
            bytesDp.SetIntValue(int64(query.avgBytesScanned.Float64))
            if query.warehouseName.Valid </span><span class="cov8" title="1">{
                bytesDp.Attributes().PutStr("warehouse.name", query.warehouseName.String)
            }</span>
            <span class="cov8" title="1">if query.queryType.Valid </span><span class="cov8" title="1">{
                bytesDp.Attributes().PutStr("query.type", query.queryType.String)
            }</span>
            <span class="cov8" title="1">bytesDp.Attributes().PutStr("data.source", "information_schema")</span>
        }
    }
}

func (s *snowflakeScraper) addWarehouseLoadMetrics(scopeMetrics pmetric.ScopeMetrics, loads []warehouseLoadRow, now pcommon.Timestamp) <span class="cov8" title="1">{
    for _, load := range loads </span><span class="cov8" title="1">{
        // Running queries
        if load.avgRunning.Valid </span><span class="cov8" title="1">{
            metric := scopeMetrics.Metrics().AppendEmpty()
            metric.SetName("snowflake.warehouse.queries.running")
            metric.SetDescription("Average queries running (REAL-TIME)")
            metric.SetUnit("{queries}")
            gauge := metric.SetEmptyGauge()
            dp := gauge.DataPoints().AppendEmpty()
            dp.SetTimestamp(now)
            dp.SetDoubleValue(load.avgRunning.Float64)
            if load.warehouseName.Valid </span><span class="cov8" title="1">{
                dp.Attributes().PutStr("warehouse.name", load.warehouseName.String)
            }</span>
            <span class="cov8" title="1">dp.Attributes().PutStr("data.source", "information_schema")</span>
        }
        
        // Queued due to overload
        <span class="cov8" title="1">if load.avgQueuedLoad.Valid </span><span class="cov8" title="1">{
            queuedMetric := scopeMetrics.Metrics().AppendEmpty()
            queuedMetric.SetName("snowflake.warehouse.queries.queued.overload")
            queuedMetric.SetDescription("Average queries queued due to overload (REAL-TIME)")
            queuedMetric.SetUnit("{queries}")
            queuedGauge := queuedMetric.SetEmptyGauge()
            queuedDp := queuedGauge.DataPoints().AppendEmpty()
            queuedDp.SetTimestamp(now)
            queuedDp.SetDoubleValue(load.avgQueuedLoad.Float64)
            if load.warehouseName.Valid </span><span class="cov8" title="1">{
                queuedDp.Attributes().PutStr("warehouse.name", load.warehouseName.String)
            }</span>
            <span class="cov8" title="1">queuedDp.Attributes().PutStr("data.source", "information_schema")</span>
        }
        
        // Queued for provisioning
        <span class="cov8" title="1">if load.avgQueuedProvisioning.Valid </span><span class="cov8" title="1">{
            provMetric := scopeMetrics.Metrics().AppendEmpty()
            provMetric.SetName("snowflake.warehouse.queries.queued.provisioning")
            provMetric.SetDescription("Average queries queued for provisioning (REAL-TIME)")
            provMetric.SetUnit("{queries}")
            provGauge := provMetric.SetEmptyGauge()
            provDp := provGauge.DataPoints().AppendEmpty()
            provDp.SetTimestamp(now)
            provDp.SetDoubleValue(load.avgQueuedProvisioning.Float64)
            if load.warehouseName.Valid </span><span class="cov8" title="1">{
                provDp.Attributes().PutStr("warehouse.name", load.warehouseName.String)
            }</span>
            <span class="cov8" title="1">provDp.Attributes().PutStr("data.source", "information_schema")</span>
        }
        
        // Blocked queries
        <span class="cov8" title="1">if load.avgBlocked.Valid </span><span class="cov8" title="1">{
            blockedMetric := scopeMetrics.Metrics().AppendEmpty()
            blockedMetric.SetName("snowflake.warehouse.queries.blocked")
            blockedMetric.SetDescription("Average queries blocked (REAL-TIME)")
            blockedMetric.SetUnit("{queries}")
            blockedGauge := blockedMetric.SetEmptyGauge()
            blockedDp := blockedGauge.DataPoints().AppendEmpty()
            blockedDp.SetTimestamp(now)
            blockedDp.SetDoubleValue(load.avgBlocked.Float64)
            if load.warehouseName.Valid </span><span class="cov8" title="1">{
                blockedDp.Attributes().PutStr("warehouse.name", load.warehouseName.String)
            }</span>
            <span class="cov8" title="1">blockedDp.Attributes().PutStr("data.source", "information_schema")</span>
        }
    }
}

// ========== ACCOUNT_USAGE Metrics (Historical) ==========
// Metric naming: snowflake.queries.* (OTel conventions)

func (s *snowflakeScraper) addQueryMetrics(scopeMetrics pmetric.ScopeMetrics, stats []queryStatRow, now pcommon.Timestamp) <span class="cov8" title="1">{
    for _, stat := range stats </span><span class="cov8" title="1">{
        // Query count
        metric := scopeMetrics.Metrics().AppendEmpty()
        metric.SetName("snowflake.queries.count")
        metric.SetDescription("Number of queries executed (Historical)")
        metric.SetUnit("{queries}")
        gauge := metric.SetEmptyGauge()
        dp := gauge.DataPoints().AppendEmpty()
        dp.SetTimestamp(now)
        dp.SetIntValue(stat.queryCount)
        if stat.warehouseName.Valid </span><span class="cov8" title="1">{
            dp.Attributes().PutStr("warehouse.name", stat.warehouseName.String)
        }</span>
        <span class="cov8" title="1">if stat.queryType.Valid </span><span class="cov8" title="1">{
            dp.Attributes().PutStr("query.type", stat.queryType.String)
        }</span>
        <span class="cov8" title="1">if stat.executionStatus.Valid </span><span class="cov8" title="1">{
            dp.Attributes().PutStr("execution.status", stat.executionStatus.String)
        }</span>
        <span class="cov8" title="1">dp.Attributes().PutStr("data.source", "account_usage")
        
        // Execution time
        if stat.avgExecutionTime.Valid </span><span class="cov8" title="1">{
            execMetric := scopeMetrics.Metrics().AppendEmpty()
            execMetric.SetName("snowflake.queries.execution.time")
            execMetric.SetDescription("Average query execution time (Historical)")
            execMetric.SetUnit("ms")
            execGauge := execMetric.SetEmptyGauge()
            execDp := execGauge.DataPoints().AppendEmpty()
            execDp.SetTimestamp(now)
            execDp.SetIntValue(int64(stat.avgExecutionTime.Float64))
            if stat.warehouseName.Valid </span><span class="cov8" title="1">{
                execDp.Attributes().PutStr("warehouse.name", stat.warehouseName.String)
            }</span>
            <span class="cov8" title="1">if stat.queryType.Valid </span><span class="cov8" title="1">{
                execDp.Attributes().PutStr("query.type", stat.queryType.String)
            }</span>
            <span class="cov8" title="1">execDp.Attributes().PutStr("data.source", "account_usage")</span>
        }
        
        // Bytes scanned
        <span class="cov8" title="1">if stat.avgBytesScanned.Valid </span><span class="cov8" title="1">{
            bytesMetric := scopeMetrics.Metrics().AppendEmpty()
            bytesMetric.SetName("snowflake.queries.bytes.scanned")
            bytesMetric.SetDescription("Average bytes scanned per query (Historical)")
            bytesMetric.SetUnit("By")
            bytesGauge := bytesMetric.SetEmptyGauge()
            bytesDp := bytesGauge.DataPoints().AppendEmpty()
            bytesDp.SetTimestamp(now)
            bytesDp.SetIntValue(int64(stat.avgBytesScanned.Float64))
            if stat.warehouseName.Valid </span><span class="cov8" title="1">{
                bytesDp.Attributes().PutStr("warehouse.name", stat.warehouseName.String)
            }</span>
            <span class="cov8" title="1">if stat.queryType.Valid </span><span class="cov8" title="1">{
                bytesDp.Attributes().PutStr("query.type", stat.queryType.String)
            }</span>
            <span class="cov8" title="1">bytesDp.Attributes().PutStr("data.source", "account_usage")</span>
        }
        
        // Bytes written
        <span class="cov8" title="1">if stat.avgBytesWritten.Valid </span><span class="cov8" title="1">{
            writtenMetric := scopeMetrics.Metrics().AppendEmpty()
            writtenMetric.SetName("snowflake.queries.bytes.written")
            writtenMetric.SetDescription("Average bytes written per query (Historical)")
            writtenMetric.SetUnit("By")
            writtenGauge := writtenMetric.SetEmptyGauge()
            writtenDp := writtenGauge.DataPoints().AppendEmpty()
            writtenDp.SetTimestamp(now)
            writtenDp.SetIntValue(int64(stat.avgBytesWritten.Float64))
            if stat.warehouseName.Valid </span><span class="cov8" title="1">{
                writtenDp.Attributes().PutStr("warehouse.name", stat.warehouseName.String)
            }</span>
            <span class="cov8" title="1">if stat.queryType.Valid </span><span class="cov8" title="1">{
                writtenDp.Attributes().PutStr("query.type", stat.queryType.String)
            }</span>
            <span class="cov8" title="1">writtenDp.Attributes().PutStr("data.source", "account_usage")</span>
        }
        
        // Rows produced
        <span class="cov8" title="1">if stat.avgRowsProduced.Valid </span><span class="cov8" title="1">{
            rowsMetric := scopeMetrics.Metrics().AppendEmpty()
            rowsMetric.SetName("snowflake.queries.rows.produced")
            rowsMetric.SetDescription("Average rows produced per query (Historical)")
            rowsMetric.SetUnit("{rows}")
            rowsGauge := rowsMetric.SetEmptyGauge()
            rowsDp := rowsGauge.DataPoints().AppendEmpty()
            rowsDp.SetTimestamp(now)
            rowsDp.SetIntValue(int64(stat.avgRowsProduced.Float64))
            if stat.warehouseName.Valid </span><span class="cov8" title="1">{
                rowsDp.Attributes().PutStr("warehouse.name", stat.warehouseName.String)
            }</span>
            <span class="cov8" title="1">if stat.queryType.Valid </span><span class="cov8" title="1">{
                rowsDp.Attributes().PutStr("query.type", stat.queryType.String)
            }</span>
            <span class="cov8" title="1">rowsDp.Attributes().PutStr("data.source", "account_usage")</span>
        }
        
        // Compilation time
        <span class="cov8" title="1">if stat.avgCompilationTime.Valid </span><span class="cov8" title="1">{
            compMetric := scopeMetrics.Metrics().AppendEmpty()
            compMetric.SetName("snowflake.queries.compilation.time")
            compMetric.SetDescription("Average query compilation time (Historical)")
            compMetric.SetUnit("ms")
            compGauge := compMetric.SetEmptyGauge()
            compDp := compGauge.DataPoints().AppendEmpty()
            compDp.SetTimestamp(now)
            compDp.SetIntValue(int64(stat.avgCompilationTime.Float64))
            if stat.warehouseName.Valid </span><span class="cov8" title="1">{
                compDp.Attributes().PutStr("warehouse.name", stat.warehouseName.String)
            }</span>
            <span class="cov8" title="1">if stat.queryType.Valid </span><span class="cov8" title="1">{
                compDp.Attributes().PutStr("query.type", stat.queryType.String)
            }</span>
            <span class="cov8" title="1">compDp.Attributes().PutStr("data.source", "account_usage")</span>
        }
    }
}

func (s *snowflakeScraper) addCreditMetrics(scopeMetrics pmetric.ScopeMetrics, credits []creditUsageRow, now pcommon.Timestamp) <span class="cov8" title="1">{
    for _, credit := range credits </span><span class="cov8" title="1">{
        // Total credits
        metric := scopeMetrics.Metrics().AppendEmpty()
        metric.SetName("snowflake.warehouse.credits.usage.total")
        metric.SetDescription("Warehouse credit usage total")
        metric.SetUnit("{credits}")
        gauge := metric.SetEmptyGauge()
        dp := gauge.DataPoints().AppendEmpty()
        dp.SetTimestamp(now)
        dp.SetDoubleValue(credit.totalCredits)
        if credit.warehouseName.Valid </span><span class="cov8" title="1">{
            dp.Attributes().PutStr("warehouse.name", credit.warehouseName.String)
        }</span>
        <span class="cov8" title="1">dp.Attributes().PutStr("data.source", "account_usage")
        
        // Compute credits
        if credit.computeCredits.Valid </span><span class="cov8" title="1">{
            compMetric := scopeMetrics.Metrics().AppendEmpty()
            compMetric.SetName("snowflake.warehouse.credits.usage.compute")
            compMetric.SetDescription("Warehouse compute credit usage")
            compMetric.SetUnit("{credits}")
            compGauge := compMetric.SetEmptyGauge()
            compDp := compGauge.DataPoints().AppendEmpty()
            compDp.SetTimestamp(now)
            compDp.SetDoubleValue(credit.computeCredits.Float64)
            if credit.warehouseName.Valid </span><span class="cov8" title="1">{
                compDp.Attributes().PutStr("warehouse.name", credit.warehouseName.String)
            }</span>
            <span class="cov8" title="1">compDp.Attributes().PutStr("data.source", "account_usage")</span>
        }
        
        // Cloud services credits
        <span class="cov8" title="1">if credit.cloudServiceCredits.Valid </span><span class="cov8" title="1">{
            cloudMetric := scopeMetrics.Metrics().AppendEmpty()
            cloudMetric.SetName("snowflake.warehouse.credits.usage.cloud.services")
            cloudMetric.SetDescription("Warehouse cloud services credit usage")
            cloudMetric.SetUnit("{credits}")
            cloudGauge := cloudMetric.SetEmptyGauge()
            cloudDp := cloudGauge.DataPoints().AppendEmpty()
            cloudDp.SetTimestamp(now)
            cloudDp.SetDoubleValue(credit.cloudServiceCredits.Float64)
            if credit.warehouseName.Valid </span><span class="cov8" title="1">{
                cloudDp.Attributes().PutStr("warehouse.name", credit.warehouseName.String)
            }</span>
            <span class="cov8" title="1">cloudDp.Attributes().PutStr("data.source", "account_usage")</span>
        }
    }
}

func (s *snowflakeScraper) addStorageMetrics(scopeMetrics pmetric.ScopeMetrics, storage []storageUsageRow, now pcommon.Timestamp) <span class="cov8" title="1">{
    for _, st := range storage </span><span class="cov8" title="1">{
        // Total storage
        if st.totalStorageBytes.Valid </span><span class="cov8" title="1">{
            metric := scopeMetrics.Metrics().AppendEmpty()
            metric.SetName("snowflake.storage.bytes.total")
            metric.SetDescription("Total storage bytes")
            metric.SetUnit("By")
            gauge := metric.SetEmptyGauge()
            dp := gauge.DataPoints().AppendEmpty()
            dp.SetTimestamp(now)
            dp.SetIntValue(int64(st.totalStorageBytes.Float64))
            dp.Attributes().PutStr("data.source", "account_usage")
        }</span>
        
        // Stage storage
        <span class="cov8" title="1">if st.stageBytes.Valid </span><span class="cov8" title="1">{
            stageMetric := scopeMetrics.Metrics().AppendEmpty()
            stageMetric.SetName("snowflake.storage.bytes.stage")
            stageMetric.SetDescription("Stage storage bytes")
            stageMetric.SetUnit("By")
            stageGauge := stageMetric.SetEmptyGauge()
            stageDp := stageGauge.DataPoints().AppendEmpty()
            stageDp.SetTimestamp(now)
            stageDp.SetIntValue(int64(st.stageBytes.Float64))
            stageDp.Attributes().PutStr("data.source", "account_usage")
        }</span>
        
        // Failsafe storage
        <span class="cov8" title="1">if st.failsafeBytes.Valid </span><span class="cov8" title="1">{
            failsafeMetric := scopeMetrics.Metrics().AppendEmpty()
            failsafeMetric.SetName("snowflake.storage.bytes.failsafe")
            failsafeMetric.SetDescription("Failsafe storage bytes")
            failsafeMetric.SetUnit("By")
            failsafeGauge := failsafeMetric.SetEmptyGauge()
            failsafeDp := failsafeGauge.DataPoints().AppendEmpty()
            failsafeDp.SetTimestamp(now)
            failsafeDp.SetIntValue(int64(st.failsafeBytes.Float64))
            failsafeDp.Attributes().PutStr("data.source", "account_usage")
        }</span>
    }
}

func (s *snowflakeScraper) addLoginMetrics(scopeMetrics pmetric.ScopeMetrics, logins []loginHistoryRow, now pcommon.Timestamp) <span class="cov8" title="1">{
    for _, login := range logins </span><span class="cov8" title="1">{
        metric := scopeMetrics.Metrics().AppendEmpty()
        metric.SetName("snowflake.logins.count")
        metric.SetDescription("Number of login attempts")
        metric.SetUnit("{logins}")
        gauge := metric.SetEmptyGauge()
        dp := gauge.DataPoints().AppendEmpty()
        dp.SetTimestamp(now)
        dp.SetIntValue(login.loginCount)
        dp.Attributes().PutStr("is.success", login.isSuccess)
        if login.errorCode.Valid &amp;&amp; login.errorCode.String != "" </span><span class="cov8" title="1">{
            dp.Attributes().PutStr("error.code", login.errorCode.String)
        }</span>
        <span class="cov8" title="1">dp.Attributes().PutStr("data.source", "account_usage")</span>
    }
}

func (s *snowflakeScraper) addPipeMetrics(scopeMetrics pmetric.ScopeMetrics, pipes []pipeUsageRow, now pcommon.Timestamp) <span class="cov8" title="1">{
    for _, pipe := range pipes </span><span class="cov8" title="1">{
        // Pipe credits
        metric := scopeMetrics.Metrics().AppendEmpty()
        metric.SetName("snowflake.pipe.credits.usage")
        metric.SetDescription("Snowpipe credit usage")
        metric.SetUnit("{credits}")
        gauge := metric.SetEmptyGauge()
        dp := gauge.DataPoints().AppendEmpty()
        dp.SetTimestamp(now)
        dp.SetDoubleValue(pipe.totalCredits)
        if pipe.pipeName.Valid </span><span class="cov8" title="1">{
            dp.Attributes().PutStr("pipe.name", pipe.pipeName.String)
        }</span>
        <span class="cov8" title="1">dp.Attributes().PutStr("data.source", "account_usage")
        
        // Bytes inserted
        if pipe.bytesInserted.Valid </span><span class="cov8" title="1">{
            bytesMetric := scopeMetrics.Metrics().AppendEmpty()
            bytesMetric.SetName("snowflake.pipe.bytes.inserted")
            bytesMetric.SetDescription("Bytes inserted via Snowpipe")
            bytesMetric.SetUnit("By")
            bytesGauge := bytesMetric.SetEmptyGauge()
            bytesDp := bytesGauge.DataPoints().AppendEmpty()
            bytesDp.SetTimestamp(now)
            bytesDp.SetIntValue(int64(pipe.bytesInserted.Float64))
            if pipe.pipeName.Valid </span><span class="cov8" title="1">{
                bytesDp.Attributes().PutStr("pipe.name", pipe.pipeName.String)
            }</span>
            <span class="cov8" title="1">bytesDp.Attributes().PutStr("data.source", "account_usage")</span>
        }
        
        // Files inserted
        <span class="cov8" title="1">if pipe.filesInserted.Valid </span><span class="cov8" title="1">{
            filesMetric := scopeMetrics.Metrics().AppendEmpty()
            filesMetric.SetName("snowflake.pipe.files.inserted")
            filesMetric.SetDescription("Files inserted via Snowpipe")
            filesMetric.SetUnit("{files}")
            filesGauge := filesMetric.SetEmptyGauge()
            filesDp := filesGauge.DataPoints().AppendEmpty()
            filesDp.SetTimestamp(now)
            filesDp.SetIntValue(pipe.filesInserted.Int64)
            if pipe.pipeName.Valid </span><span class="cov8" title="1">{
                filesDp.Attributes().PutStr("pipe.name", pipe.pipeName.String)
            }</span>
            <span class="cov8" title="1">filesDp.Attributes().PutStr("data.source", "account_usage")</span>
        }
    }
}

func (s *snowflakeScraper) addDatabaseStorageMetrics(scopeMetrics pmetric.ScopeMetrics, dbStorage []databaseStorageRow, now pcommon.Timestamp) <span class="cov8" title="1">{
    for _, db := range dbStorage </span><span class="cov8" title="1">{
        // Database storage
        if db.avgDatabaseBytes.Valid </span><span class="cov8" title="1">{
            metric := scopeMetrics.Metrics().AppendEmpty()
            metric.SetName("snowflake.database.storage.bytes")
            metric.SetDescription("Database storage bytes")
            metric.SetUnit("By")
            gauge := metric.SetEmptyGauge()
            dp := gauge.DataPoints().AppendEmpty()
            dp.SetTimestamp(now)
            dp.SetIntValue(int64(db.avgDatabaseBytes.Float64))
            if db.databaseName.Valid </span><span class="cov8" title="1">{
                dp.Attributes().PutStr("database.name", db.databaseName.String)
            }</span>
            <span class="cov8" title="1">dp.Attributes().PutStr("data.source", "account_usage")</span>
        }
        
        // Database failsafe
        <span class="cov8" title="1">if db.avgFailsafeBytes.Valid </span><span class="cov8" title="1">{
            failsafeMetric := scopeMetrics.Metrics().AppendEmpty()
            failsafeMetric.SetName("snowflake.database.failsafe.bytes")
            failsafeMetric.SetDescription("Database failsafe bytes")
            failsafeMetric.SetUnit("By")
            failsafeGauge := failsafeMetric.SetEmptyGauge()
            failsafeDp := failsafeGauge.DataPoints().AppendEmpty()
            failsafeDp.SetTimestamp(now)
            failsafeDp.SetIntValue(int64(db.avgFailsafeBytes.Float64))
            if db.databaseName.Valid </span><span class="cov8" title="1">{
                failsafeDp.Attributes().PutStr("database.name", db.databaseName.String)
            }</span>
            <span class="cov8" title="1">failsafeDp.Attributes().PutStr("data.source", "account_usage")</span>
        }
    }
}

func (s *snowflakeScraper) addTaskHistoryMetrics(scopeMetrics pmetric.ScopeMetrics, tasks []taskHistoryRow, now pcommon.Timestamp) <span class="cov8" title="1">{
    for _, task := range tasks </span><span class="cov8" title="1">{
        // Task execution count
        metric := scopeMetrics.Metrics().AppendEmpty()
        metric.SetName("snowflake.tasks.executions.count")
        metric.SetDescription("Number of task executions")
        metric.SetUnit("{executions}")
        gauge := metric.SetEmptyGauge()
        dp := gauge.DataPoints().AppendEmpty()
        dp.SetTimestamp(now)
        dp.SetIntValue(task.executionCount)
        if task.databaseName.Valid </span><span class="cov8" title="1">{
            dp.Attributes().PutStr("database.name", task.databaseName.String)
        }</span>
        <span class="cov8" title="1">if task.schemaName.Valid </span><span class="cov8" title="1">{
            dp.Attributes().PutStr("schema.name", task.schemaName.String)
        }</span>
        <span class="cov8" title="1">if task.taskName.Valid </span><span class="cov8" title="1">{
            dp.Attributes().PutStr("task.name", task.taskName.String)
        }</span>
        <span class="cov8" title="1">if task.state.Valid </span><span class="cov8" title="1">{
            dp.Attributes().PutStr("task.state", task.state.String)
        }</span>
        <span class="cov8" title="1">dp.Attributes().PutStr("data.source", "account_usage")
        
        // Task scheduled time
        if task.avgExecutionTime.Valid </span><span class="cov8" title="1">{
            schedMetric := scopeMetrics.Metrics().AppendEmpty()
            schedMetric.SetName("snowflake.tasks.execution.time")
            schedMetric.SetDescription("Average task execution time")
            schedMetric.SetUnit("ms")
            schedGauge := schedMetric.SetEmptyGauge()
            schedDp := schedGauge.DataPoints().AppendEmpty()
            schedDp.SetTimestamp(now)
            schedDp.SetIntValue(int64(task.avgExecutionTime.Float64))
            if task.databaseName.Valid </span><span class="cov8" title="1">{
                schedDp.Attributes().PutStr("database.name", task.databaseName.String)
            }</span>
            <span class="cov8" title="1">if task.schemaName.Valid </span><span class="cov8" title="1">{
                schedDp.Attributes().PutStr("schema.name", task.schemaName.String)
            }</span>
            <span class="cov8" title="1">if task.taskName.Valid </span><span class="cov8" title="1">{
                schedDp.Attributes().PutStr("task.name", task.taskName.String)
            }</span>
            <span class="cov8" title="1">schedDp.Attributes().PutStr("data.source", "account_usage")</span>
        }
    }
}

func (s *snowflakeScraper) addReplicationMetrics(scopeMetrics pmetric.ScopeMetrics, replications []replicationUsageRow, now pcommon.Timestamp) <span class="cov8" title="1">{
    for _, repl := range replications </span><span class="cov8" title="1">{
        // Replication credits
        metric := scopeMetrics.Metrics().AppendEmpty()
        metric.SetName("snowflake.replication.credits.usage")
        metric.SetDescription("Database replication credit usage")
        metric.SetUnit("{credits}")
        gauge := metric.SetEmptyGauge()
        dp := gauge.DataPoints().AppendEmpty()
        dp.SetTimestamp(now)
        dp.SetDoubleValue(repl.totalCredits)
        if repl.databaseName.Valid </span><span class="cov8" title="1">{
            dp.Attributes().PutStr("database.name", repl.databaseName.String)
        }</span>
        <span class="cov8" title="1">dp.Attributes().PutStr("data.source", "account_usage")
        
        // Bytes transferred
        if repl.bytesTransferred.Valid </span><span class="cov8" title="1">{
            bytesMetric := scopeMetrics.Metrics().AppendEmpty()
            bytesMetric.SetName("snowflake.replication.bytes.transferred")
            bytesMetric.SetDescription("Bytes transferred via replication")
            bytesMetric.SetUnit("By")
            bytesGauge := bytesMetric.SetEmptyGauge()
            bytesDp := bytesGauge.DataPoints().AppendEmpty()
            bytesDp.SetTimestamp(now)
            bytesDp.SetIntValue(int64(repl.bytesTransferred.Float64))
            if repl.databaseName.Valid </span><span class="cov8" title="1">{
                bytesDp.Attributes().PutStr("database.name", repl.databaseName.String)
            }</span>
            <span class="cov8" title="1">bytesDp.Attributes().PutStr("data.source", "account_usage")</span>
        }
    }
}

func (s *snowflakeScraper) addAutoClusteringMetrics(scopeMetrics pmetric.ScopeMetrics, clusterings []autoClusteringRow, now pcommon.Timestamp) <span class="cov8" title="1">{
    for _, cluster := range clusterings </span><span class="cov8" title="1">{
        // Auto-clustering credits
        metric := scopeMetrics.Metrics().AppendEmpty()
        metric.SetName("snowflake.clustering.auto.credits.usage")
        metric.SetDescription("Auto-clustering credit usage")
        metric.SetUnit("{credits}")
        gauge := metric.SetEmptyGauge()
        dp := gauge.DataPoints().AppendEmpty()
        dp.SetTimestamp(now)
        dp.SetDoubleValue(cluster.totalCredits)
        if cluster.databaseName.Valid </span><span class="cov8" title="1">{
            dp.Attributes().PutStr("database.name", cluster.databaseName.String)
        }</span>
        <span class="cov8" title="1">if cluster.schemaName.Valid </span><span class="cov8" title="1">{
            dp.Attributes().PutStr("schema.name", cluster.schemaName.String)
        }</span>
        <span class="cov8" title="1">if cluster.tableName.Valid </span><span class="cov8" title="1">{
            dp.Attributes().PutStr("table.name", cluster.tableName.String)
        }</span>
        <span class="cov8" title="1">dp.Attributes().PutStr("data.source", "account_usage")
        
        // Bytes reclustered
        if cluster.bytesReclustered.Valid </span><span class="cov8" title="1">{
            bytesMetric := scopeMetrics.Metrics().AppendEmpty()
            bytesMetric.SetName("snowflake.clustering.auto.bytes.reclustered")
            bytesMetric.SetDescription("Bytes reclustered by auto-clustering")
            bytesMetric.SetUnit("By")
            bytesGauge := bytesMetric.SetEmptyGauge()
            bytesDp := bytesGauge.DataPoints().AppendEmpty()
            bytesDp.SetTimestamp(now)
            bytesDp.SetIntValue(int64(cluster.bytesReclustered.Float64))
            if cluster.databaseName.Valid </span><span class="cov8" title="1">{
                bytesDp.Attributes().PutStr("database.name", cluster.databaseName.String)
            }</span>
            <span class="cov8" title="1">if cluster.schemaName.Valid </span><span class="cov8" title="1">{
                bytesDp.Attributes().PutStr("schema.name", cluster.schemaName.String)
            }</span>
            <span class="cov8" title="1">if cluster.tableName.Valid </span><span class="cov8" title="1">{
                bytesDp.Attributes().PutStr("table.name", cluster.tableName.String)
            }</span>
            <span class="cov8" title="1">bytesDp.Attributes().PutStr("data.source", "account_usage")</span>
        }
        
        // Rows reclustered
        <span class="cov8" title="1">if cluster.rowsReclustered.Valid </span><span class="cov8" title="1">{
            rowsMetric := scopeMetrics.Metrics().AppendEmpty()
            rowsMetric.SetName("snowflake.clustering.auto.rows.reclustered")
            rowsMetric.SetDescription("Rows reclustered by auto-clustering")
            rowsMetric.SetUnit("{rows}")
            rowsGauge := rowsMetric.SetEmptyGauge()
            rowsDp := rowsGauge.DataPoints().AppendEmpty()
            rowsDp.SetTimestamp(now)
            rowsDp.SetIntValue(int64(cluster.rowsReclustered.Float64))
            if cluster.databaseName.Valid </span><span class="cov8" title="1">{
                rowsDp.Attributes().PutStr("database.name", cluster.databaseName.String)
            }</span>
            <span class="cov8" title="1">if cluster.schemaName.Valid </span><span class="cov8" title="1">{
                rowsDp.Attributes().PutStr("schema.name", cluster.schemaName.String)
            }</span>
            <span class="cov8" title="1">if cluster.tableName.Valid </span><span class="cov8" title="1">{
                rowsDp.Attributes().PutStr("table.name", cluster.tableName.String)
            }</span>
            <span class="cov8" title="1">rowsDp.Attributes().PutStr("data.source", "account_usage")</span>
        }
    }
}

// ========== EVENT TABLES Metrics (SECONDS-LEVEL LATENCY!) ==========

func (s *snowflakeScraper) addEventTableMetrics(scopeMetrics pmetric.ScopeMetrics, events []eventTableRow, now pcommon.Timestamp) <span class="cov8" title="1">{
    eventCounts := make(map[string]map[string]int64)
    
    for _, event := range events </span><span class="cov8" title="1">{
        if _, exists := eventCounts[event.eventType]; !exists </span><span class="cov8" title="1">{
            eventCounts[event.eventType] = make(map[string]int64)
        }</span>
        
        <span class="cov8" title="1">severity := "INFO"
        if event.severity.Valid </span><span class="cov8" title="1">{
            severity = event.severity.String
        }</span>
        <span class="cov8" title="1">eventCounts[event.eventType][severity]++</span>
    }
    
    <span class="cov8" title="1">for eventType, severityCounts := range eventCounts </span><span class="cov8" title="1">{
        for severity, count := range severityCounts </span><span class="cov8" title="1">{
            metric := scopeMetrics.Metrics().AppendEmpty()
            metric.SetName(fmt.Sprintf("snowflake.events.%s.count", eventType))
            metric.SetDescription(fmt.Sprintf("Event table %s event count (REAL-TIME)", eventType))
            metric.SetUnit("{events}")
            gauge := metric.SetEmptyGauge()
            dp := gauge.DataPoints().AppendEmpty()
            dp.SetTimestamp(now)
            dp.SetIntValue(count)
            dp.Attributes().PutStr("event.type", eventType)
            dp.Attributes().PutStr("severity", severity)
            dp.Attributes().PutStr("data.source", "event_table")
        }</span>
    }
    
    <span class="cov8" title="1">errorCount := int64(0)
    for _, event := range events </span><span class="cov8" title="1">{
        if event.errorMessage.Valid &amp;&amp; event.errorMessage.String != "" </span><span class="cov8" title="1">{
            errorCount++
        }</span>
    }
    
    <span class="cov8" title="1">if errorCount &gt; 0 </span><span class="cov8" title="1">{
        errorMetric := scopeMetrics.Metrics().AppendEmpty()
        errorMetric.SetName("snowflake.events.errors.count")
        errorMetric.SetDescription("Event table error count (REAL-TIME)")
        errorMetric.SetUnit("{errors}")
        gauge := errorMetric.SetEmptyGauge()
        dp := gauge.DataPoints().AppendEmpty()
        dp.SetTimestamp(now)
        dp.SetIntValue(errorCount)
        dp.Attributes().PutStr("data.source", "event_table")
    }</span>
}

// ========== ORGANIZATION Metrics (Multi-Account) ==========

func (s *snowflakeScraper) addOrgCreditMetrics(scopeMetrics pmetric.ScopeMetrics, orgCredits []orgCreditUsageRow, now pcommon.Timestamp) <span class="cov8" title="1">{
    for _, credit := range orgCredits </span><span class="cov8" title="1">{
        metric := scopeMetrics.Metrics().AppendEmpty()
        metric.SetName("snowflake.organization.credits.usage")
        metric.SetDescription("Organization-level credit usage")
        metric.SetUnit("{credits}")
        gauge := metric.SetEmptyGauge()
        dp := gauge.DataPoints().AppendEmpty()
        dp.SetTimestamp(now)
        dp.SetDoubleValue(credit.totalCredits)
        if credit.organizationName.Valid </span><span class="cov8" title="1">{
            dp.Attributes().PutStr("organization.name", credit.organizationName.String)
        }</span>
        <span class="cov8" title="1">if credit.accountName.Valid </span><span class="cov8" title="1">{
            dp.Attributes().PutStr("account.name", credit.accountName.String)
        }</span>
        <span class="cov8" title="1">if credit.serviceType.Valid </span><span class="cov8" title="1">{
            dp.Attributes().PutStr("service.type", credit.serviceType.String)
        }</span>
        <span class="cov8" title="1">dp.Attributes().PutStr("data.source", "organization_usage")</span>
    }
}

func (s *snowflakeScraper) addOrgStorageMetrics(scopeMetrics pmetric.ScopeMetrics, orgStorage []orgStorageUsageRow, now pcommon.Timestamp) <span class="cov8" title="1">{
    for _, storage := range orgStorage </span><span class="cov8" title="1">{
        // Total storage
        if storage.avgStorageBytes.Valid </span><span class="cov8" title="1">{
            metric := scopeMetrics.Metrics().AppendEmpty()
            metric.SetName("snowflake.organization.storage.bytes.total")
            metric.SetDescription("Organization-level total storage")
            metric.SetUnit("By")
            gauge := metric.SetEmptyGauge()
            dp := gauge.DataPoints().AppendEmpty()
            dp.SetTimestamp(now)
            dp.SetIntValue(int64(storage.avgStorageBytes.Float64))
            if storage.organizationName.Valid </span><span class="cov8" title="1">{
                dp.Attributes().PutStr("organization.name", storage.organizationName.String)
            }</span>
            <span class="cov8" title="1">if storage.accountName.Valid </span><span class="cov8" title="1">{
                dp.Attributes().PutStr("account.name", storage.accountName.String)
            }</span>
            <span class="cov8" title="1">dp.Attributes().PutStr("data.source", "organization_usage")</span>
        }
        
        // Stage storage
        <span class="cov8" title="1">if storage.avgStageBytes.Valid </span><span class="cov8" title="1">{
            stageMetric := scopeMetrics.Metrics().AppendEmpty()
            stageMetric.SetName("snowflake.organization.storage.bytes.stage")
            stageMetric.SetDescription("Organization-level stage storage")
            stageMetric.SetUnit("By")
            stageGauge := stageMetric.SetEmptyGauge()
            stageDp := stageGauge.DataPoints().AppendEmpty()
            stageDp.SetTimestamp(now)
            stageDp.SetIntValue(int64(storage.avgStageBytes.Float64))
            if storage.organizationName.Valid </span><span class="cov8" title="1">{
                stageDp.Attributes().PutStr("organization.name", storage.organizationName.String)
            }</span>
            <span class="cov8" title="1">if storage.accountName.Valid </span><span class="cov8" title="1">{
                stageDp.Attributes().PutStr("account.name", storage.accountName.String)
            }</span>
            <span class="cov8" title="1">stageDp.Attributes().PutStr("data.source", "organization_usage")</span>
        }
        
        // Failsafe storage
        <span class="cov8" title="1">if storage.avgFailsafeBytes.Valid </span><span class="cov8" title="1">{
            failsafeMetric := scopeMetrics.Metrics().AppendEmpty()
            failsafeMetric.SetName("snowflake.organization.storage.bytes.failsafe")
            failsafeMetric.SetDescription("Organization-level failsafe storage")
            failsafeMetric.SetUnit("By")
            failsafeGauge := failsafeMetric.SetEmptyGauge()
            failsafeDp := failsafeGauge.DataPoints().AppendEmpty()
            failsafeDp.SetTimestamp(now)
            failsafeDp.SetIntValue(int64(storage.avgFailsafeBytes.Float64))
            if storage.organizationName.Valid </span><span class="cov8" title="1">{
                failsafeDp.Attributes().PutStr("organization.name", storage.organizationName.String)
            }</span>
            <span class="cov8" title="1">if storage.accountName.Valid </span><span class="cov8" title="1">{
                failsafeDp.Attributes().PutStr("account.name", storage.accountName.String)
            }</span>
            <span class="cov8" title="1">failsafeDp.Attributes().PutStr("data.source", "organization_usage")</span>
        }
    }
}

func (s *snowflakeScraper) addOrgDataTransferMetrics(scopeMetrics pmetric.ScopeMetrics, transfers []orgDataTransferRow, now pcommon.Timestamp) <span class="cov8" title="1">{
    for _, transfer := range transfers </span><span class="cov8" title="1">{
        if transfer.totalBytesTransferred.Valid </span><span class="cov8" title="1">{
            metric := scopeMetrics.Metrics().AppendEmpty()
            metric.SetName("snowflake.organization.data.transfer.bytes")
            metric.SetDescription("Organization-level cross-account data transfer")
            metric.SetUnit("By")
            gauge := metric.SetEmptyGauge()
            dp := gauge.DataPoints().AppendEmpty()
            dp.SetTimestamp(now)
            dp.SetIntValue(int64(transfer.totalBytesTransferred.Float64))
            if transfer.organizationName.Valid </span><span class="cov8" title="1">{
                dp.Attributes().PutStr("organization.name", transfer.organizationName.String)
            }</span>
            <span class="cov8" title="1">if transfer.sourceAccountName.Valid </span><span class="cov8" title="1">{
                dp.Attributes().PutStr("source.account", transfer.sourceAccountName.String)
            }</span>
            <span class="cov8" title="1">if transfer.targetAccountName.Valid </span><span class="cov8" title="1">{
                dp.Attributes().PutStr("target.account", transfer.targetAccountName.String)
            }</span>
            <span class="cov8" title="1">if transfer.sourceRegion.Valid </span><span class="cov8" title="1">{
                dp.Attributes().PutStr("source.region", transfer.sourceRegion.String)
            }</span>
            <span class="cov8" title="1">if transfer.targetRegion.Valid </span><span class="cov8" title="1">{
                dp.Attributes().PutStr("target.region", transfer.targetRegion.String)
            }</span>
            <span class="cov8" title="1">dp.Attributes().PutStr("data.source", "organization_usage")</span>
        }
    }
}

func (s *snowflakeScraper) addOrgContractMetrics(scopeMetrics pmetric.ScopeMetrics, contracts []orgContractUsageRow, now pcommon.Timestamp) <span class="cov8" title="1">{
    for _, contract := range contracts </span><span class="cov8" title="1">{
        // Credits used
        metric := scopeMetrics.Metrics().AppendEmpty()
        metric.SetName("snowflake.organization.contract.credits.used")
        metric.SetDescription("Organization contract credits used")
        metric.SetUnit("{credits}")
        gauge := metric.SetEmptyGauge()
        dp := gauge.DataPoints().AppendEmpty()
        dp.SetTimestamp(now)
        dp.SetDoubleValue(contract.totalCreditsUsed)
        if contract.organizationName.Valid </span><span class="cov8" title="1">{
            dp.Attributes().PutStr("organization.name", contract.organizationName.String)
        }</span>
        <span class="cov8" title="1">if contract.contractNumber.Valid </span><span class="cov8" title="1">{
            dp.Attributes().PutStr("contract.number", fmt.Sprintf("%d", contract.contractNumber.Int64))
        }</span>
        <span class="cov8" title="1">dp.Attributes().PutStr("data.source", "organization_usage")
        
        // Credits billed
        if contract.totalCreditsBilled.Valid </span><span class="cov8" title="1">{
            billedMetric := scopeMetrics.Metrics().AppendEmpty()
            billedMetric.SetName("snowflake.organization.contract.credits.billed")
            billedMetric.SetDescription("Organization contract credits billed")
            billedMetric.SetUnit("{credits}")
            billedGauge := billedMetric.SetEmptyGauge()
            billedDp := billedGauge.DataPoints().AppendEmpty()
            billedDp.SetTimestamp(now)
            billedDp.SetDoubleValue(contract.totalCreditsBilled.Float64)
            if contract.organizationName.Valid </span><span class="cov8" title="1">{
                billedDp.Attributes().PutStr("organization.name", contract.organizationName.String)
            }</span>
            <span class="cov8" title="1">if contract.contractNumber.Valid </span><span class="cov8" title="1">{
                billedDp.Attributes().PutStr("contract.number", fmt.Sprintf("%d", contract.contractNumber.Int64))
            }</span>
            <span class="cov8" title="1">billedDp.Attributes().PutStr("data.source", "organization_usage")</span>
        }
    }
}

// ========== CUSTOM QUERIES ==========

func (s *snowflakeScraper) addCustomQueryMetrics(scopeMetrics pmetric.ScopeMetrics, result customQueryResult, now pcommon.Timestamp) <span class="cov8" title="1">{
    metricType := result.metricType
    if metricType == "" </span><span class="cov0" title="0">{
        metricType = "gauge"
    }</span>
    
    <span class="cov8" title="1">var queryConfig *CustomQuery
    for i := range s.config.CustomQueries.Queries </span><span class="cov8" title="1">{
        if s.config.CustomQueries.Queries[i].Name == result.name </span><span class="cov8" title="1">{
            queryConfig = &amp;s.config.CustomQueries.Queries[i]
            break</span>
        }
    }
    
    <span class="cov8" title="1">if queryConfig == nil </span><span class="cov0" title="0">{
        s.logger.Warn("Custom query config not found", zap.String("query_name", result.name))
        return
    }</span>
    
    <span class="cov8" title="1">for _, row := range result.rows </span><span class="cov8" title="1">{
        metric := scopeMetrics.Metrics().AppendEmpty()
        metric.SetName(fmt.Sprintf("snowflake.custom.%s", result.name))
        metric.SetDescription(fmt.Sprintf("Custom query: %s", result.name))
        metric.SetUnit("1")
        
        valueInterface, exists := row[queryConfig.ValueColumn]
        if !exists </span><span class="cov0" title="0">{
            s.logger.Warn("Value column not found in query result",
                zap.String("query_name", result.name),
                zap.String("value_column", queryConfig.ValueColumn))
            continue</span>
        }
        
        <span class="cov8" title="1">gauge := metric.SetEmptyGauge()
        dp := gauge.DataPoints().AppendEmpty()
        dp.SetTimestamp(now)
        
        var floatValue float64
        switch v := valueInterface.(type) </span>{
        case float64:<span class="cov8" title="1">
            floatValue = v</span>
        case float32:<span class="cov8" title="1">
            floatValue = float64(v)</span>
        case int64:<span class="cov8" title="1">
            floatValue = float64(v)</span>
        case int32:<span class="cov8" title="1">
            floatValue = float64(v)</span>
        case int:<span class="cov8" title="1">
            floatValue = float64(v)</span>
        case string:<span class="cov8" title="1">
            parsed, err := strconv.ParseFloat(v, 64)
            if err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to parse string value to float",
                    zap.String("query_name", result.name),
                    zap.String("value", v),
                    zap.Error(err))
                continue</span>
            }
            <span class="cov8" title="1">floatValue = parsed</span>
        case []byte:<span class="cov0" title="0">
            parsed, err := strconv.ParseFloat(string(v), 64)
            if err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to parse byte value to float",
                    zap.String("query_name", result.name),
                    zap.Error(err))
                continue</span>
            }
            <span class="cov0" title="0">floatValue = parsed</span>
        default:<span class="cov0" title="0">
            s.logger.Warn("Unsupported value type in custom query",
                zap.String("query_name", result.name),
                zap.String("type", fmt.Sprintf("%T", v)),
                zap.Any("value", v))
            continue</span>
        }
        
        <span class="cov8" title="1">dp.SetDoubleValue(floatValue)
        
        for _, labelCol := range queryConfig.LabelColumns </span><span class="cov8" title="1">{
            if labelValue, exists := row[labelCol]; exists &amp;&amp; labelValue != nil </span><span class="cov8" title="1">{
                dp.Attributes().PutStr(labelCol, fmt.Sprintf("%v", labelValue))
            }</span>
        }
        
        <span class="cov8" title="1">dp.Attributes().PutStr("data.source", "custom_query")</span>
    }
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
